// Source FGD for TrenchBroom





//////////////////////////////////////////////////////
//
// base class definitions
//
//////////////////////////////////////////////////////

@BaseClass = Angles
[ 
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "This entity's orientation in the world. Pitch is rotation around the Y axis, " +
		"yaw is the rotation around the Z axis, roll is the rotation around the X axis."
]

@BaseClass = Targetname
[
	targetname(target_source) : "Name"
]

@BaseClass = Parentname
[ 
	parentname(string) : "Parent" : : "The name of this entity's parent in the movement hierarchy. Entities with parents move with their parent."
]

@BaseClass = Target
[
	target(target_destination) : "Target"
	killtarget(target_destination) : "Killtarget"
]

@BaseClass = EnableDisable
[
	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@BaseClass = RenderFxChoices
[
	renderfx(choices) :"Render FX" : 0 =
	[
		0: "Normal"
		1: "Slow Pulse"
		2: "Fast Pulse"
		3: "Slow Wide Pulse"
		4: "Fast Wide Pulse"
		9: "Slow Strobe"
		10: "Fast Strobe"
		11: "Faster Strobe"
		12: "Slow Flicker"
		13: "Fast Flicker"
		5: "Slow Fade Away"
		6: "Fast Fade Away"
		7: "Slow Become Solid"
		8: "Fast Become Solid"
		14: "Constant Glow"
		15: "Distort"
		16: "Hologram (Distort + fade)"
		23: "Cull By Distance (TEST)"
		24: "Spotlight FX"
		26: "Fade Near"
	]
]

@BaseClass = Shadow
[
	disableshadows(choices) : "Disable shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@BaseClass base(RenderFxChoices) = RenderFields 
[
	rendermode(choices) : "Render Mode" : 0 : "Used to set a non-standard rendering mode on this entity. See also 'FX Amount' and 'FX Color'." =
	[
		0: "Normal"
		1: "Color"
		2: "Texture"
		3: "Glow"
		4: "Solid"
		5: "Additive"
		7: "Additive Fractional Frame"
		9: "World Space Glow"
		10: "Dont Render"
	]
	renderamt(integer) : "FX Amount (0 - 255)" : 255 : "The FX amount is used by the selected Render Mode."
	rendercolor(string) : "FX Color (R G B)" : "255 255 255" : "The FX color is used by the selected Render Mode."

	disablereceiveshadows(choices) : "Disable Receiving Shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@BaseClass = DXLevelChoice
[ 
	mindxlevel(choices) : "Minimum DX Level" : 0 = 
	[
		0 : "default (lowest)"
		70 : "dx7"
		80 : "dx8.0 (4600Ti)"
		81 : "dx8.1 (FX5200)"
		90 : "dx9 SM2.0"
		95 : "dx9 SM3.0"
	]
	maxdxlevel(choices) : "Maximum DX Level" : 0 = 
	[
		0 : "default (highest)"
		60 : "dx6"
		70 : "dx7"
		80 : "dx8.0 (4600Ti)"
		81 : "dx8.1 (FX5200)"
		90 : "dx9 SM2.0"
		95 : "dx9 SM3.0"
	]
]

@BaseClass = Inputfilter
[
	InputFilter(choices) : "Input Filter" : 0 : "Used to specify which inputs this entity will accept." =
	[
		0 : "Allow all inputs"
		8 : "Ignore Touch/Untouch"
		16 : "Ignore Use"
		32 : "Ignore All"
	]
]

@BaseClass = Global 
[ 
	globalname(string) : "Global Entity Name" : "" : "Name by which this entity is linked to another entity in a different map. When the player transitions to a new map, entities in the new map with globalnames matching entities in the previous map will have the previous map's state copied over their state."
]

@BaseClass base(Targetname, Parentname, EnableDisable, Global) = TriggerOnce
[
	spawnflags(flags) = 
	[
		1: "Clients" : 1
		2: "NPCs" : 0
		4: "Pushables": 0
		8: "Physics Objects" : 0
		16: "Only player ally NPCs" : 0
		32: "Only clients in vehicles" : 0
		64: "Everything (not including physics debris)" : 0
		512: "Only clients *not* in vehicles" : 0
		1024: "Physics debris" : 0
		2048: "Only NPCs in vehicles (respects player ally flag)" : 0
		4096: "Disallow Bots" : 0
	]

	filtername(string) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."
]

@BaseClass base(Targetname, Parentname, EnableDisable, TriggerOnce) = Trigger []

@BaseClass
	size(-24 -24 0, 24 24 80)
	color(0 64 0) = PlayerClass []

@BaseClass color(255 255 0) = Light
[
	_light(string) : "Brightness" : "255 255 255 400" : "The RGB color and brightness of the light. Colors must be between 0 and 255; brightness can be anything."
	_lightHDR(string) : "HDR Brightness" : "-1 -1 -1 1" : "Brightness override used in HDR mode. Default is -1 -1 -1 1, which means no change."
	_lightHDRscale(integer) : "HDR Brightness Scale" : 1 : "A simple intensity multiplier used when compiling HDR lighting."
	style(choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10 : "Flourescent flicker"
		2 : "Slow deep pulse"
		11 : "Slow shallow pulse"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	pattern(string) : "Custom Appearance" : "" : "A string of characters, like a sequence of piano keys, that define a pattern of brightness. a is dark and z is full intensity. Applies only to lights with a targetname."
	_constant_attn(integer) : "Constant Attenuation" : 0
	_quadratic_attn(integer) : "Quadratic Attenuation" : 1
	_linear_attn(integer) : "Linear Attenuation" : 0
	_fifty_percent_distance(string) : "50 percent falloff distance" : ""
	_zero_percent_distance(string) : "0 percent falloff distance" : ""
	_hardfalloff(integer) : "Hard Falloff" : 0 : "Causes lights to fall to exactly zero beyond the 0% distance. May cause unrealistic lighting if not used carefully."
]

@BaseClass = DamageFilter
[ 
	damagefilter(string) : "Damage Filter" : "" : "Name of the filter entity that controls which entities can damage us."
]

@BaseClass base(Targetname, Parentname, RenderFields, Global, Shadow) = Door
[
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	noise1(string) : "Start Sound" : : "Sound to play when the door starts moving."
	noise2(string) : "Stop Sound" : : "Sound to play when the door stops moving."
	startclosesound(string) : "Start Close Sound" : : "(Optional) Sound to play when the door starts closing."
	closesound(string) : "Stop Close Sound" : : "(Optional) Sound to play when the door stops closing."
	wait(integer) : "Delay Before Reset (-1 stay)" : 4 : "Amount of time, in seconds, after the door has opened before it closes. Once it has closed, it can be used again. If the value is set to -1, the door never closes itself."
	lip(integer) : "Lip" : 0 : "The amount, in inches, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	dmg(integer) : "Blocking Damage" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	forceclosed(choices) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects." =
	[
		0 : "No"
		1 : "Yes"
	]
	ignoredebris(choices) : "Ignore Debris" : 0 : "If set this will change the door's collision group to one that ignore collisions with debris objects (note that this is not compatible with the non-solid-to-player spawnflag)." =
	[
		0 : "No"
		1 : "Yes"
	]

	message(string) : "Message If Triggered"		// NEEDHELP: Looks like this was removed
	health(integer) : "Health (shoot open)" : 0		// NEEDHELP: Looks like this was removed

	locked_sound(string) : "Locked Sound" : : "Sound played when the player tries to use the door, and fails because it's locked."
	unlocked_sound(string) : "Unlocked Sound" : : "Sound played when the button is door."

	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open"
	]

	spawnflags(flags) =
	[
		1 : "Starts Open - OBSOLETE, use 'Spawn Position' key instead" : 0
		4 : "Non-solid to Player" : 0
		8: "Passable" : 0
		32: "Toggle" : 0
		256:"Use Opens" : 0
		512: "NPCs Can't" : 0
		1024: "Touch Opens" : 1
		2048: "Starts locked" : 0
		4096:	"Door Silent" : 0
	]
	locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the door, and fails because it's locked." =  
	[
		0: "None"
		1: "Gen. Access Denied"
		2: "Security Lockout"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance Door"
		9: "Broken Shut Door"
	]
	unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the door is unlocked." = 
	[
		0: "None"
		1: "Gen. Access Granted"
		2: "Security Disengaged"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance area"
	]	
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	loopmovesound(choices) : "Loop Moving Sound?" : 0 : "If set to true, the door's 'Start Sound' will be continually looped until the door finishes moving." =
	[
		0: "No"
		1: "Yes"
	]
	solidbsp(choices) : "Solid Type" : 1 =
	[
		0 : "VPhysics"
		1 : "BSP"
	]
]

@BaseClass = ResponseContext
[
	// Pre-defined contexts at server startup time (set by mapper)
	ResponseContext(string) : "Response Contexts" : "" : "Response system context(s) for this entity. Format should be: 'key:value,key2:value2,etc'. When this entity speaks, the list of keys & values will be passed to the response rules system."
]

@BaseClass base(Targetname, DamageFilter, Shadow) = Breakable
[
	ExplodeDamage(float) : "Explosion Damage" : "0" : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. See also 'Explosion Radius'."
	ExplodeRadius(float) : "Explosion Radius" : "0" : "If non-zero, when this entity breaks it will create an explosion with a radius of the specified amount. See also 'Explosion Damage'."
	PerformanceMode(choices) : "Performance Mode" : 0 : "Used to limit the amount of gibs produced when this entity breaks, for performance reasons." =
	[
		0 : "Normal"
		1 : "No Gibs"
		2 : "Full Gibs on All Platforms"
		3 : "Reduced gibs"
	]
	
	BreakModelMessage(string) : "Break Model Message" : "" : "If set, will use this break model message instead of the normal break behavior."
]

@BaseClass base(Breakable, Parentname, Global) = BreakableBrush
[
	spawnflags(flags) =
	[
		1 : "Only Break on Trigger" : 0
		2 : "Break on Touch" : 0
		4 : "Break on Pressure" : 0
		512: "Break immediately on Physics" : 0
		1024: "Don't take physics damage" : 0
		2048: "Don't allow bullet penetration": 0
	]

	propdata(choices) : "Prop Data" : 0 : "Set to the best approximation of the size and material of this entity's brushes. If set, it will override this entity's health and damage taken from various weapons. See the propdata.txt file in the scripts directory of your MOD to get a detailed list of what each entry specifies." =
	[
		0 : "None"
		1 : "Wooden.Tiny"
		2 : "Wooden.Small"
		3 : "Wooden.Medium"
		4 : "Wooden.Large"
		5 : "Wooden.Huge"
		6 : "Metal.Small"
		7 : "Metal.Medium"
		8 : "Metal.Large"
		9 : "Cardboard.Small"
		10 : "Cardboard.Medium"
		11 : "Cardboard.Large"
		12 : "Stone.Small"
		13 : "Stone.Medium"
		14 : "Stone.Large"
		15 : "Stone.Huge"
		16 : "Glass.Small"
		17 : "Plastic.Small"
		18 : "Plastic.Medium"
		19 : "Plastic.Large"
		20 : "Pottery.Small"
		21 : "Pottery.Medium"
		22 : "Pottery.Large"
		23 : "Pottery.Huge"
		24 : "Glass.Window"
	]

	health(integer) : "Strength" : 1 : "Number of points of damage to take before breaking. 0 means don't break."
	material(choices) :"Material Type" : 0 : "Set to the material type of the brush. Used to decide what sounds to make when damaged, and what gibs to produce when broken." =
	[
		0: "Glass"
		1: "Wood"
		2: "Metal"		
		3: "Flesh"
		4: "CinderBlock"
		5: "Ceiling Tile"
		6: "Computer"
		7: "Unbreakable Glass"
		8: "Rocks"
		// 9: "Web(defunct)"
		10: "None"
	]
	explosion(choices) : "Gibs Direction" : 0 : "Used to decide which direction to throw gibs when broken." =
	[
		0: "Random"
		1: "Relative to Attack"
		2: "Use Precise Gib Dir"
	]

	gibdir(angle) : "Precise Gib Direction" : "0 0 0" : "Specifies the direction to throw gibs when this breakable breaks. Be sure to select Use Precise Gib Dir in the Gibs Direction field!"

	nodamageforces(choices) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	gibmodel(string) : "Gib Model" : "" : "Used by HL1Port to specify a custom gib model to break into, overriding the 'Material Type'."
	spawnobject(choices) : "Spawn On Break" : 0 : "When broken, an entity of the selected type will be created." =
	[
		1:	"item_battery"				
		2:	"item_healthkit"			
		3:	"item_ammo_pistol"			
		4:	"item_ammo_pistol_large"	
		5:	"item_ammo_smg1"			
		6:	"item_ammo_smg1_large"	
		7:	"item_ammo_ar2"			
		8:	"item_ammo_ar2_large"	
		9:	"item_box_buckshot"		
		10:	"item_flare_round"			
		11:	"item_box_flare_rounds"		
		12:	"item_ml_grenade"		
		13:	"item_smg1_grenade"			
		14:	"item_box_sniper_rounds"	
		15:	"unused1"			
		16:	"weapon_stunstick"		
		17:	"weapon_ar1"				
		18:	"weapon_ar2"			
		19:	"unused2"				
		20:	"weapon_ml"					
		21:	"weapon_smg1"				
		22:	"weapon_smg2"				
		23:	"weapon_slam"				
		24:	"weapon_shotgun"			
		25:	"weapon_molotov"
		26:	"item_dynamic_resupply"							
	]
	explodemagnitude(integer) : "Explode Magnitude" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage."
	pressuredelay(float) : "Pressure Delay" : "0" : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
]

@BaseClass base(Breakable) = BreakableProp
[
	spawnflags(flags) =
	[
		16 : "Break on Touch" : 0
		32 : "Break on Pressure" : 0
	]
	pressuredelay(float) : "Pressure Delay" : "0" : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
]

@BaseClass base(Targetname, Angles, RenderFields, DamageFilter, ResponseContext, Shadow) color(0 200 200) = BaseNPC
[
	target(target_destination) : "Target Path Corner" : : "If set, the name of a path corner entity that this NPC will walk to, after spawning."
	squadname(String) : "Squad Name" : : "NPCs that are in the same squad (i.e. have matching squad names) will share information about enemies, and will take turns attacking and covering each other."
	hintgroup(String) : "Hint Group" : "" : "Hint groups are used by NPCs to restrict their hint-node searching to a subset of the map's hint nodes. Only hint nodes with matching hint group names will be considered by this NPC."
	hintlimiting(choices) : "Hint Limit Nav" : 0 : "Limits NPC to using specified hint group for navigation requests, but does not limit local navigation." =
	[
		0 : "No"
		1 : "Yes"
	]

	spawnflags(Flags) = 
	[
		1 : "Wait Till Seen" : 0
		2 : "Gag (No IDLE sounds until angry)" : 0
		4 : "Fall to ground (unchecked means *teleport* to ground)" : 1
		8 : "Drop Healthkit" : 0
		16 : "Efficient - Don't acquire enemies or avoid obstacles" : 0
		128: "Wait For Script" : 0
		256: "Long Visibility/Shoot" : 0
		512: "Fade Corpse" : 1
		1024: "Think outside PVS" : 0
		2048: "Template NPC (used by npc_maker, will not spawn)" : 0
		4096: "Do Alternate collision for this NPC (player avoidance)" : 0
		8192: "Don't drop weapons" : 0
		16384 : "Ignore player push (dont give way to player)" : 0
	]

	//initialidle(string) : "Initial Idle Activity" :: "Activity the NPC should use to idle until becomes alert"
	sleepstate(choices) : "Sleep State" : 0 : "Holds the NPC in stasis until specified condition. See also 'Wake Radius' and 'Wake Squad'." =
	[
		0 : "None"
		1 : "Waiting for threat"
		2 : "Waiting for PVS"
		3 : "Waiting for input, ignore PVS"
		4 : "Auto PVS"
		5 : "Auto PVS after PVS"
	]

	wakeradius(float) : "Wake Radius" : "0" : "Auto-wake if player within this distance"
	wakesquad(choices) : "Wake Squad" : 0 : "Wake all of the NPCs squadmates if the NPC is woken" =
	[
		0 : "No"
		1 : "Yes"
	]

	enemyfilter(target_destination) : "Enemy Filter" : "" : "Filter by which to filter potential enemies"
	
	ignoreunseenenemies(choices) : "Ignore unseen enemies" : 0 : "Prefer visible enemies, regardless of distance or relationship priority" = 
	[
		0 : "No"
		1 : "Yes"
	]

	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this character is hit by a physics object. With a value of 0 the NPC will take no damage from physics."
]





//////////////////////////////////////////////////////
//
// world entity definition
//
//////////////////////////////////////////////////////

@SolidClass = worldspawn : "World Entity"
[
	message(string) : "Map description"
	skyname(string) : "SkyBox Texture Name" : "sky_day01_01"
	chaptertitle(string) : "Chapter Title Message" : "" : "Chapter Title that appears onscreen when this level starts."
	startdark(choices) : "Level Fade In" : 0 =
	[	
		0 : "No"
		1 : "Yes"
	]
	detailvbsp(string) : "Detail.vbsp file" : "detail.vbsp" : "Detail.vbsp file to use for emitting detail props (found	in directory <root>/modname)"
	detailmaterial(string) : "Detail material file" : "detail/detailsprites" : "Material for detail sprites to use for drawing detail props"
	coldworld(choices) : "World is cold" : 0 =
	[	
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = ambient_generic : "Universal ambient sound. Use it to play and control a single sound."
[
	message(sound) : "Sound Name" : "" : "Name of the GameSound entry for the sound to play. Also supports direct .wav filenames."
	health(integer) : "Volume" : 10 : "Sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
	preset(choices) :"Dynamic Presets" : 0 =
	[
		0: "None"
		1: "Huge Machine"
		2: "Big Machine"
		3: "Machine"
		4: "Slow Fade in"  
		5: "Fade in"
		6: "Quick Fade in"
		7: "Slow Pulse"
		8: "Pulse"
		9: "Quick pulse"
		10: "Slow						// NEEDHELP Oscillator"
		11: "Oscillator"
		12: "Quick Oscillator"
		13: "Grunge pitch"
		14: "Very low pitch"
		15: "Low pitch"
		16: "High pitch"
		17: "Very high pitch"
		18: "Screaming pitch"
		19: "Oscillate spinup/down"
		20: "Pulse spinup/down"
		21: "Random pitch"
		22: "Random pitch fast"
		23: "Incremental Spinup"
		24: "Alien"
		25: "Bizzare"
		26: "Planet X"
		27: "Haunted"
	]
	volstart(integer) : "Start Volume" : 0							// NEEDHELP
	fadeinsecs(integer) : "Fade in time in seconds (0-100)" : 0		// NEEDHELP
	fadeoutsecs(integer) : "Fade out time in seconds (0-100)" : 0	// NEEDHELP
	pitch(integer) : "Pitch" : 100 : "Sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	pitchstart(integer) : "Start Pitch" : 100						// NEEDHELP
	spinup(integer) : "Spin up time (0-100)" : 0					// NEEDHELP
	spindown(integer) : "Spin down time (0-100)" : 0				// NEEDHELP
	lfotype(integer) : "LFO type 0)off 1)sqr 2)tri 3)rnd" : 0		// NEEDHELP
	lforate(integer) : "LFO rate (0-1000)" : 0						// NEEDHELP
	lfomodpitch(integer) : "LFO mod pitch (0-100)" : 0				// NEEDHELP
	lfomodvol(integer) : "LFO mod vol (0-100)" : 0					// NEEDHELP
	cspinup(integer) : "Incremental Spinup Count" : 0				// NEEDHELP
	radius(string) : "Max Audible Distance" : "1250" : "Maximum distance at which this sound is audible."
	spawnflags(flags) =
	[
		1: "Play everywhere" : 0
		16:"Start Silent": 1
		32:"Is NOT Looped": 1
	]
	soundflags(choices) :"Sound Flags" : 0 : "Additional options for your sound." =
	[
		0: "None"
		128: "Pause when game is paused"
		256: "Ignore phonemes (no lip-syncing)"
		1024: "Don't overwrite existing sound on channel (untested)"
	]
	SourceEntityName(target_destination) : "SourceEntityName" : : "If an entity is specified, sound will come from this named entity instead of the location of ambient_generic."
]

@PointClass base(Targetname) = env_zoom : 
	"An entity that can be used to control the player's FOV. Useful for scenes where the player's view is being controlled, or player-usable binoculars/telescopes, etc."
[
	Rate(float) : "Seconds to reach target" : "1.0" : "Amount of time it should take to reach the specified FOV."
	FOV(integer) : "Target FOV" : 75 : "FOV that this entity should set the player's FOV to when active."

	spawnflags(flags) =
	[
		1: "Allow Suit Zoom" : 0
	]
]

@PointClass base(Targetname) = env_screenoverlay: 
	"An entity that can display and control a set of screen overlays, to be displayed over the player's view. Useful for view effects like drunkenness, or teleporter afterimages, etc."
[
	OverlayName1(string) : "Overlay Name 1" : "" : "Name of the first overlay material to display."
	OverlayTime1(float) : "Overlay Duration 1" : "1.0" : "Amount of time that the first overlay should be displayed for, after which it will begin showing the second overlay."
	OverlayName2(string) : "Overlay Name 2" : "" : "Name of the second overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime2(float) : "Overlay Duration 2" : "1.0" : "Amount of time that the second overlay should be displayed for, after which it will begin showing the third overlay."
	OverlayName3(string) : "Overlay Name 3" : "" : "Name of the third overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime3(float) : "Overlay Duration 3" : "1.0" : "Amount of time that the third overlay should be displayed for, after which it will begin showing the fourth overlay."
	OverlayName4(string) : "Overlay Name 4" : "" : "Name of the fourth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime4(float) : "Overlay Duration 4" : "1.0" : "Amount of time that the fourth overlay should be displayed for, after which it will begin showing the fifth overlay."
	OverlayName5(string) : "Overlay Name 5" : "" : "Name of the fifth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime5(float) : "Overlay Duration 5" : "1.0" : "Amount of time that the fifth overlay should be displayed for, after which it will begin showing the sixth overlay."
	OverlayName6(string) : "Overlay Name 6" : "" : "Name of the sixth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime6(float) : "Overlay Duration 6" : "1.0" : "Amount of time that the sixth overlay should be displayed for, after which it will begin showing the seventh overlay."
	OverlayName7(string) : "Overlay Name 7" : "" : "Name of the seventh overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime7(float) : "Overlay Duration 7" : "1.0" : "Amount of time that the seventh overlay should be displayed for, after which it will begin showing the eighth overlay."
	OverlayName8(string) : "Overlay Name 8" : "" : "Name of the eighth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime8(float) : "Overlay Duration 8" : "1.0" : "Amount of time that the eighth overlay should be displayed for, after which it will begin showing the ninth overlay."
	OverlayName9(string) : "Overlay Name 9" : "" : "Name of the ninth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime9(float) : "Overlay Duration 9" : "1.0" : "Amount of time that the ninth overlay should be displayed for, after which it will begin showing the tenth overlay."
	OverlayName10(string) : "Overlay Name 10" : "" : "Name of the tenth overlay material to display. If left blank, overlay displaying will finish, and this entity will consider itself done."
	OverlayTime10(float) : "Overlay Duration 10" : "1.0" : "Amount of time that the tenth overlay should be displayed for, after which this entity will stop displaying overlays."
]

@PointClass base(Targetname) = env_screeneffect :
	"Allows screenspace effects to be played on the player's view."
[
	type(choices) : "Effect Type" : 0 : "Which effect to use." =
	[
		0 : "Advisor Stun"
		1 : "Intro Blur"
		2 : "Groggy Vision"
	]
]

@PointClass base(Targetname) = env_texturetoggle : 
	"An entity that allows you to change the textures on other brush-built entities."
[
	target(target_destination) : "Target Brush(es)." 
]

@PointClass base(Targetname, Angles) = env_splash : 
	"An entity that creates a splash effect at its origin. If the 'find water surface' spawnflag is set, it will instead trace down below itself to find the water surface on which to create splashes."
[
	scale(float) : "Scale of the splash" : "8.0"

	spawnflags(flags) =
	[
		1: "Automatically find water surface (place entity above water)" : 0
		2: "Diminish with depth (diminished completely in 10 feet of water)" : 1
	]
]

@PointClass base(Parentname) color(180 10 180) = env_particlelight : 
	"An entity that can be used to light the smoke particles emitted by env_smokestack entities. Does not light any other particle types."
[
	Color(color255) : "Color" : "255 0 0" : "Color emitted by this light." 
	Intensity(integer) : "Intensity" : 5000

	directional(choices) : "Directional" : 0 : "If this is specified, then this light will use the bump map on the particles. Each particle system can have one ambient and one directional light." =
	[
		0 : "No"
		1 : "Yes"
	]

	PSName(string) : "Particle System Entity" : "" : "Set this to the name of the env_smokestack that you want this light to affect."
]

@PointClass base(Targetname, Angles) color(255 0 0) = env_sun : 
	"An entity to control & draw a sun effect in the sky."
[
	target(target_destination) : "Viewer entity" : : "Name of an entity used to determine where the sun is in the skybox. The sun should be lined up on a line from this entity to the env_sun entity."
	
	use_angles(choices) : "UseAngles" : 0 : "The old way to orient env_sun is to point it at a target. The new way is to specify the angles. If you use the new way, set this property to YES." = 
	[
		0 : "No"
		1 : "Yes"
	]

	pitch(integer) : "Pitch" : 0

	rendercolor(color255) : "Sun Color (R G B)" : "100 80 80"
	overlaycolor(color255) : "Overlay Color (R G B)" : "0 0 0" : "A value of 0 0 0 will act the old way."
	
	size(integer) : "Size" : 16
	overlaysize(integer) : "Overlay Size" : -1 : "A value of -1 means the overlay will act the old way."
	
	material(sprite) : "Material Name" : "sprites/light_glow02_add_noz" : "Material of the inner glow."
	overlaymaterial(sprite) : "Overlay Material Name" : "sprites/light_glow02_add_noz" : "Material of the overlay glow."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
]

@PointClass base(Targetname) = game_ragdoll_manager : 
	"An entity to control the number of ragdolls in the world, for performance reasons." 
[
	MaxRagdollCount(integer) : "Max Ragdoll Count" : -1 : "Sets the max number of ragdolls that can be in the world at a time (if they are flagged to fade). Set to -1 if you want to use the default value (g_ragdoll_maxcount)."
	MaxRagdollCountDX8(integer) : "Max Ragdoll Count DX8" : -1 : "Sets the max number of ragdolls that can be in the world at a time on DX8 hardware (if they are flagged to fade). Set to -1 if you want to use the 'Max Ragdoll Count' value."

	SaveImportant(choices) : "Save Important Ragdolls" : 0 : "Should the ragdoll manager make sure ally ragdolls aren't deleted?" = 
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = game_gib_manager : "An entity to control the number of gibs in the world, for performance reasons." 
[
	maxpieces(integer)	: "Max Gib Count" : -1 : "Sets the max number of gib that can be spawned at a time. (-1=no limit)"
	maxpiecesdx8(integer)	: "Max Gib Count On DX8" : -1 : "Sets the max number of gib that can be spawned at a time under DX8. (-1=use Max Gib Count setting)"
	allownewgibs(choices)	: "Allow New Gibs To Spawn" : 0 : "If true, when the max gib count is reached, oldest gibs are removed as new gibs spawn. If false, new gibs will not be spawned once the gib limit is reached." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Parentname, Targetname, Angles) color(255 128 0) = env_lightglow : 
	"An entity that puts an additive glow in the world, mostly used over light sources."
[
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	VerticalGlowSize(integer) : "Vertical Size" : 30
	HorizontalGlowSize(integer) : "Horizontal Size" : 30
	MinDist(integer) : "Minimum Distance" : 500 : "The distance at which this effect will be fully translucent."
	MaxDist(integer) : "Maximum Distance" : 2000 : "The distance at which this effect will be at full intensity."
	OuterMaxDist(integer) : "Outer Maximum Distance" : 0 : "If larger than the maximum distance, this is the length at which the glow will fade completely out, between the span of the maximum distance and this length."
	GlowProxySize(float) : "Glow Proxy Geometry Size" : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space. So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."

	spawnflags(flags) =
	[
		1: "Visible only from front" : 0
	]
]

@PointClass base(Parentname, Angles) color(255 255 255) = env_smokestack : 
	"An entity that spits out a constant stream of smoke. See particlezoo.vmf for sample usage. You can place up to two env_particlelight entities near the smoke stack to add ambient light to its particles."
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	BaseSpread(integer) : "Spread at the base" : 20 : "Amount of random spread in the origins of the smoke particles when they're spawned."
	SpreadSpeed(integer) : "Spread Speed" : 15 : "Amount of random spread in the velocity of the smoke particles after they're spawned."
	Speed(integer) : "Speed" : 30 : "The speed at which the smoke particles move after they're spawned."
	StartSize(integer) : "Particle start size" : 20 : "Size of the smoke particles when they're first emitted."
	EndSize(integer) : "Particle end size" : 30 : "Size of the smoke particles at the point they fade out completely."
	Rate(integer) : "Emission rate" : 20 : "Rate at which to emit smoke particles (i.e. particles to emit per second)."
	JetLength(integer) : "Length of smoke trail" : 180 : "Length of the smokestack. Lifetime of the smoke particles is derived from this & particle speed."
	WindAngle(integer) : "Wind X/Y Angle" : 0 : "This specifies the wind direction. It is an angle in the XY plane. WindSpeed specifies the strength of the wind."
	WindSpeed(integer) : "Wind Speed" : 0 : "The strength of the wind."
	SmokeMaterial(string) : "Particle material" : "particle/SmokeStack.vmt" : "Material of the smoke particles emitted by this stack."
	twist(integer) : "Twist" : 0 : "The amount, in degrees per second, that the smoke particles twist around the origin."
	roll(float) : "Roll Speed": "0" : "Amount of roll in degrees per second."
	
	rendercolor(color255) : "Base Color (R G B)" : "255 255 255"

	renderamt(integer) : "Translucency" : 255
]

@PointClass base(Targetname) = env_fade : 
	"An entity that controls screen fades."
[
	spawnflags(flags) =
	[
		1: "Fade From" : 0
		2: "Modulate" : 0
		4: "Triggering player only" : 0
		8: "Stay Out" : 0
		16: "Don't purge other active fades" : 0
	]
	duration(string) : "Duration (seconds)" : "2" : "The time that it will take to fade the screen in or out."
	ReverseFadeDuration(float) : "Reverse Fade Duration (seconds)" : "2" : "The duration of the reverse fade."
	holdtime(string) : "Hold Fade (seconds)" : "0" : "The time to hold the faded in/out state."
	renderamt(integer) : "Fade Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0"
]

@PointClass base(Targetname) = env_player_surface_trigger : 
	"An entity that monitors the material of the surface the player is standing on, and fires outputs whenever it changes to/from a specific material."
[
	gamematerial(choices) : "Game Material to Watch" : "0" : "The material to watch. When the player stands on/off this material, this entity's outputs will be fired." =
	[
		0 : "None (player's in the air)"
		67 : "Concrete"
		77 : "Metal"
		68 : "Dirt"
		86 : "Vent"
		71 : "Grate"
		84 : "Tile"
		83 : "Slosh"
		87 : "Wood"
		80 : "Computer"
		89 : "Glass"
		70 : "Flesh"
		73 : "Clip"
		79 : "Foliage"
		78 : "Sand"
	]
]

@PointClass base(Targetname) = env_tonemap_controller : 
	"An entity that controls the HDR tonemapping for the player. Think of it as a method of controlling the exposure of the player's eyes." []





//////////////////////////////////////////////////////
//
// world entity definition
//
//////////////////////////////////////////////////////

@BaseClass base(Targetname, Parentname) = gibshooterbase
[
	angles(string) : "Gib Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the gibs will fly."
	m_iGibs(integer) : "Number of Gibs" : 3 : "Total number of gibs to shoot each time it's activated."
	delay(string) : "Delay between shots" : "0" : "Delay (in seconds) between shooting each gib. If 0, all gibs shoot at once."
	gibangles(string) : "Gib Angles (Pitch Yaw Roll)" : "0 0 0" : "The orientation of the spawned gibs."
	gibanglevelocity(string) : "Max angular velocity" : "0" : "How fast (degrees/sec) the gib pieces should spin. They will spin on x and y axis at between 10% and 100% of this speed."
	m_flVelocity(integer) : "Gib Velocity" : 200 : "Speed of the fired gibs"
	m_flVariance(string) : "Course Variance" : "0.15" : "How much variance in the direction gibs are fired."
	m_flGibLife(string) : "Gib Life" : "4" : "Time in seconds for gibs to live +/- 5%"
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."

	spawnflags(Flags) = 
	[
		1 : "Repeatable"  : 0
	]
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) = env_beam : 
	"An entity that creates a visible beam between two points. The points can be attached to entities to make the beam move around."
[
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	Radius(integer) : "Radius" : 256 : "If the 'Random Strike' spawnflag is set, this radius determines the area within which the endpoints will randomly strike."
	life(string) : "Life (seconds 0 = infinite)" : "1" : "Amount of time before the beam dies. Setting to zero will make the beam stay forever."
	BoltWidth(float) : "Width of beam" : "2" : "Pixel width of the beam."
	NoiseAmplitude(float) : "Amount of noise (0-255)" : "0" : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framerate(integer) : "Frames per 10 seconds" : 0 : "Framerate at which the beam texture should animate, if it has multiple frames."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	StrikeTime(string) : "Strike again time (secs)" : "1" : "Refire time between random strikes of the beam. Only used if the 'Random Strike' spawnflag is set."
	damage(string) : "Damage / second" : "0" : "How much damage this beam does per second to things it hits when it is continually on, or instantaneously if it strikes. For continuous damage, the value should be greater than 10 or it may not work."
	LightningStart(target_destination) : "Start Entity" : "" : "Entity that the beam starts at."
	LightningEnd(target_destination) : "Ending Entity" : "" : "Entity that the beam ends at."
	decalname(string) : "Decal Name" : "Bigshot" : "Decal to be applied at the end of the beam"
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."

	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		2 : "Toggle" : 0
		4 : "Random Strike" : 0
		8 : "Ring" : 0
		16: "StartSparks" : 0
		32: "EndSparks" : 0
		64: "Decal End" : 0
		128: "Shade Start" : 0
		256: "Shade End" : 0
		512: "Taper Out" : 0
	]

	TouchType(choices) : "Touch Type (tripwire)" : 0 : "If you want the beam to fire an output when touched by entities, choose the entity type here." =
	[	
		0 : "Not a tripwire"
		1 : "Player Only"
		2 : "NPC Only"
		3 : "Player or NPC"
		4 : "Player or NPC or Physprop"
	]

	filtername(PointClass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."
]

@SolidClass base(Targetname, Parentname, Angles) = env_embers : 
	"An entity used to create a volume in which to spawn fire embers." 
[
	particletype(choices) : "Ember type" : 0 =
	[
		0 : "Normal"
		1 : "Smooth Fade"
		2 : "Pulled"
	]

	density(integer) : "Density (particles per second)" : 50
	lifetime(integer) : "Particle Lifetime (seconds)" : 4
	speed(integer) : "Particle Speed (units per second)" : 32
	rendercolor(color255) : "Ember Color (R G B)" : "255 255 255"	

	spawnflags(Flags) = 
	[
		1 : "Start On"  : 0
		2 : "Toggle" : 0
	]
]

@PointClass base(Targetname, Parentname) size(-16 -16 -16, 16 16 16) color(255 0 0) = env_blood : 
	"An entity used to spawn blood effects." 
[
	spraydir(angle) : "Spray Direction (Pitch Yaw Roll)" : "0 0 0" : "The general direction that the blood should spray and the direction to trace to apply the decal."
	color(choices) : "Blood Color" : 0 =
	[
		0 : "Red (Human)"
		1 : "Yellow (Alien)"
	]
	amount(string) : "Amount of blood (damage to simulate)" : "100"
	spawnflags(flags) =
	[
		1: "Random Direction" : 0
		2: "Blood Stream" : 0
		4: "On Player" : 0
		8: "Spray decals" : 0
	]
]

@SolidClass base(Targetname, Parentname) = env_bubbles : 
	"An entity used to create a volume in which to spawn bubbles." 
[
	density(integer) : "Bubble density" : 2
	frequency(integer) : "Bubble frequency" : 2
	current(integer) : "Speed of Current" : 0 : "The speed of the water current in the volume	 used to move the bubbles."
	spawnflags(Flags) = 
	[
		1 : "Start Off"  :	0
	]
]

@PointClass base(Targetname, Parentname) = env_explosion : 
	"An entity that creates an explosion at its origin."
[
	iMagnitude(Integer) : "Magnitude" : 100 : "The amount of damage done by the explosion."
	// If no radius override, magnitude will determine radius	
	iRadiusOverride(Integer) : "Radius Override" : 0 : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	fireballsprite(sprite) : "Fireball Sprite" : "sprites/zerogxplode.spr"
	rendermode(choices) : "Render Mode" : 5 =
	[
		0: "Normal"
		4: "Solid"
		5: "Additive"
	]
	spawnflags(flags) =
	[
		1: "No Damage" : 0
		2: "Repeatable" : 0
		4: "No Fireball" : 0
		8: "No Smoke" : 0
		16: "No Decal" : 0
		32: "No Sparks" : 0
		64: "No Sound" : 0
		128: "Random Orientation" : 0
		256: "No Fireball Smoke" : 0
		512: "No particles" : 0
		1024: "No DLights" : 0
		2048: "Don't clamp Min" : 0
		4096: "Don't clamp Max" : 0
		8192: "Damage above surface only" : 0
		16384: "Generic damage" : 0
	]

	ignoredEntity(target_destination) : "Ignored Entity" : : "Do not harm or affect the named entity."
]

@PointClass base(Targetname, Parentname) color(200 50 0)  size(-8 -8 -8, 8 8 8) = env_smoketrail : 
	"An entity that creates a smoke trail." 
[
	opacity(float) : "Sprite Opacity" : "0.75" : "Opacity of the sprites (range from 0 - 1)."
	spawnrate(float) : "Spawn Rate" : "20" : "Number of particles to emit each second."
	lifetime(float) : "Particle Life Time" : "5.0" : "Number of seconds until each particle dies."
	startcolor(color255) : "Start Color" : "192 192 192" : "Starting color of the emitted particles."
	endcolor(color255) : "End Color" : "160 160 160" : "Ending color of the emitted particles."
	emittime(float) : "Emitter Life Time" : "0" : "Number of seconds until the env_smoketrail stops emitting particles. 0 means never stop emitting particles."
	minspeed(float) : "Minimum Random Speed" : "10" : "Minimum randomly-directed speed to use for emitted particles."
	maxspeed(float) : "Maximum Random Speed" : "20" : "Maximum randomly-directed speed to use for emitted particles."
	mindirectedspeed(float) : "Minimum Directed Speed" : "0" : "Minimum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	maxdirectedspeed(float) : "Maximum Directed Speed" : "0" : "Maximum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	startsize(float) : "Starting particle size" : "15" : "Starting particle size."
	endsize(float) : "Ending particle size" : "50" : "Ending particle size."
	spawnradius(float) : "Spawn radius" : "15" : "Distance from env_smoketrail at which particles are emitted."

	firesprite(sprite) : "Fire Sprite" : "sprites/firetrail.spr"
	smokesprite(sprite) : "Smoke Puff" : "sprites/whitepuff.spr"
]

@PointClass base(Targetname, Parentname) = env_physexplosion : 
	"An entity that creates an explosion at its origin. If the no-damage spawnflag is set, the explosion won't be visible, but will apply force to any physics objects within its radius."
[
	magnitude(string) : "Magnitude" : "100" : "Amount of physics force applied by the explosion."
	radius(string) : "Clamp Radius (0 = auto)" : "0" : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	targetentityname(target_destination) : "Limit to Entity" : "" : "If specified, the explosion will only affect the matching entity."

	spawnflags(flags) =
	[
		1 : "No Damage - Only Force" : 1
		2 : "Push players" : 0
		4 : "Push radially - not as a sphere" : 0
		8 : "Test LOS before pushing" : 0
		16 : "Disorient player if pushed" : 0
	]

	inner_radius(float) : "Inner radius" : "0" : "If not zero, the LOS is calculated from a point intersecting this sphere."
]

@PointClass base(Targetname, Parentname) = env_physimpact : 
	"An entity that will cause a physics impact on another entity."
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "Direction to project the impact."
	magnitude(integer) : "Magnitude" : 100 : "Strength of the impact."
	distance(integer) : "Distance" : 0 : "How far to project the impact (if 0 uses a default value)."
	directionentityname(target_destination) : "Point to Entity" : "" : "If set, 'Distance' and Angle settings are ignored and the direction and distance to the target entity will be used."

	spawnflags(flags) =
	[
		1: "No fall-off" : 0
		2: "Infinite Length" : 0
		4: "Ignore Mass" : 0
		8: "Ignore Surface Normal When Applying Force" : 1
	]
]

@PointClass base(Targetname, Parentname, EnableDisable) color(0 180 0) = env_fire : 
	"An entity that handles a single flame at its origin. The flame causes heat 'damage' to other env_fire entities around it, and will eventually ignite non-flaming env_fire entities nearby, causing the fire to spread."
[
	health(integer) : "Duration" : 30 : "Amount of time the fire will burn."
	firesize(integer) : "Size" : 64 : "Height (in world units) of the flame."
	fireattack(integer) : "Attack" : 4 : "Amount of time the fire takes to grow to full strength."
	firetype(choices) : "Type" : 0 =
	[
		0 : "Natural"
		1 : "Plasma"
	]
	spawnflags(flags) =
	[
		1:	"Infinite Duration" : 0
		2:	"Smokeless" : 0
		4:	"Start On" : 0
		8:	"Start Full" : 0
		16:	"Don't drop" : 0
		32:	 "No glow" : 0
		128:	 "Delete when out" : 0
		256:	 "Visible from above" : 0
	]

	ignitionpoint(float) : "Ignition Point" : "32" : "Amount of heat 'damage' to take before this flame should ignite."
	damagescale(float) : "Damage Scale" : "1.0" : "Multiplier of the burn damage done by the flame."
]

@PointClass base(Targetname, Parentname) color(255 255 0) = env_firesource : 
	"An entity that provides heat to all nearby env_fire entities. Cannot be extinguished."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 0
	]

	fireradius(float) : "Radius" : "128" : "The radius around this entity in which to provide heat."
	firedamage(float) : "Intensity / Damage" : "10" : "Amount of heat 'damage' to apply to env_fire entities within the radius."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) color(255 255 0) = env_firesensor : 
	"An entity that detects changes in heat nearby."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 1
	]

	fireradius(float) : "Radius" : "128" : "The radius around this entity in which to detect heat changes."
	heatlevel(float) : "Heat level" : "32" : "The target heat level to check for. Outputs are fired when the heat moves over this target level (increasing or decreasing)."
	heattime(float) : "Time at level" : "0" : "The amount of time the heat level must spend over the target level before the 'OnHeatLevelStart' output is fired."
]

@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 180 0) = env_entity_igniter : 
	"An entity that catches a target entity on fire. If the entity is an animating model, it will have sprite flames attached to its skeleton. Otherwise the entity will emit particle flame puffs."
[
	target(target_destination) : "Entity to ignite" : : "Name of the entity to catch on fire."
	lifetime(float) : "Lifetime in seconds" : "10" : "Duration of flames."
]

@PointClass base(Targetname, DXLevelChoice, Angles) color(255 255 255) = env_fog_controller : 
	"An entity that controls the fog and view distance in the map."
[

	// Starting fog parameters for the level. These are selectable per LOD.	
	fogenable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles(choices) : "Use Angles for Fog Dir" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Direction" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0"
	fogend(string) : "Fog End" : "2000.0"
	fogmaxdensity(float) : "Fog Max Density [0..1]" : "1"

	foglerptime(float) : "Interpolate time" : "0"
	
	farz(string) : "Far Z Clip Plane" : "-1"
	
	spawnflags(flags) =
	[
		1 : "Master (Has priority if multiple env_fog_controllers exist)" : 0
	]
]

@PointClass base(Targetname, Parentname, Angles) color(255 255 255) = env_steam : 
	"An entity used to create a jet of steam."
[
	spawnflags(flags) =
	[
		1 : "Emissive" : 0
	]

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	//Type of particle to spew out
	type(choices) : "Particle Type" : 0 =
	[
		0 : "Normal"
		1 : "Heat Wave"
	]

	SpreadSpeed(integer) : "Spread Speed" : 15 : "The amount of random spread in the particle's velocity after they spawn."
	Speed(integer) : "Speed" : 120 : "The default speed at which the particles move after they spawn."
	StartSize(integer) : "Particle start size" : 10 : "The initial size of the particles after they spawn."
	EndSize(integer) : "Particle end size" : 25 : "The size of the particles at the point at which they are removed."
	Rate(integer) : "Emission rate" : 26 : "The rate of particle emission. i.e. particles per second."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	JetLength(integer) : "Length of steam jet" : 80 : "The length of the jet determines the lifetime of each particle."
	renderamt(integer) : "Translucency" : 255
	rollspeed(float) : "How fast does the particles spin" : "8"
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) = env_laser : 
	"An entity that creates a laser beam between itself and a given target."
[
	LaserTarget(target_destination) : "Target of Laser" : : "Name of entity, or entities, to strike at. The target is randomly chosen if there are multiple entities matching the given name."
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	width(float) : "Width of Beam" : "2" : "The width of the laser beam, in pixels."
	NoiseAmplitude(integer) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the laser beam."
	EndSprite(sprite) : "End Sprite" : "" : "If specified, this sprite will be drawn at the end of the laser beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	damage(string) : "Damage / second" : "100" : "How much damage this laser does. per second. to things it hits."
	dissolvetype(choices) : "Dissolve Type" : "None" =
	[
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	]
	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		16: "StartSparks" : 0
		32: "EndSparks" : 0
		64: "Decal End" : 0
	]
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_message : 
	"An entity that draws a text message on player's HUDs."
[
	message(string) : "Message Text"
	spawnflags(flags) =
	[
		1: "Play Once" : 0
		2: "All Clients" : 0
	]
	messagesound(sound) : "Sound Effect" : "" : "When the message is shown, this sound effect will be played, originating from this entity."
	messagevolume(string) : "Volume 0-10" : "10" : "Volume of the sound effect."
	messageattenuation(Choices) : "Sound Radius" : 0 =
	[
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	]
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_hudhint : 
	"An entity to control the display of HUD hints. HUD hints are used to show the player what key is bound to a particular command."
[
	spawnflags(flags) =
	[
		1: "All Players" : 0
	]

	message(string) : "Hint Text (localized)" : "" : "This should be set to match the desired HUD hint entry in the hl2\resource\valve_english.txt."
]

@PointClass base(Targetname, Parentname) = env_shake : 
	"An entity to control screen shake on players." 
[
	spawnflags(flags) =
	[
		1: "GlobalShake" : 0
		//2: "Disrupt player control" : 0 // doesn't work
		4: "In Air" : 0		// shakes objects even if they are not onground
		8: "Physics" : 0	// shakes physically as well as the camera
		16: "Ropes" : 0		// shakes ropes too.
		32: "DON'T shake view (for shaking ropes or physics only)" : 0
		64: "DON'T Rumble Controller" : 0
	]

	amplitude(float) : "Amplitude (0-16)" : "4" : "The amount of noise in the screen shake. Should be a range between 0 and 16."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
	duration(float) : "Duration (seconds)" : "1" : "The length of time in which to shake the player's screens."
	frequency(float) : "Frequency" : "2.5" : "The frequency used to apply the screen shake. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
]

@PointClass size(-4 -4 -4, 4 4 4) base(Targetname, Parentname) = env_viewpunch :
	"Causes a view punch on players." 
[
	spawnflags(flags) =
	[
		1: "Punch all players (ignore radius)" : 0
		2: "Punch players in the air" : 0
	]

	punchangle(angle) : "Punch angles" : "0 0 90" : "The punch angles to apply."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
]

@PointClass base(Targetname, Parentname) = env_rotorwash_emitter :
	"Creates rotorwash." 
[
	altitude(float) : "Altitude" : "1024" : "Altitude the rotorwash will show up."
]

@PointClass base(gibshooterbase) = gibshooter : 
	"An entity that shoots out gibs. Style of body part depends on language type." []

@PointClass base(gibshooterbase, RenderFields) = env_shooter : 
	"An entity that shoots models, or sprites, out of its origin."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out. Can be a .mdl or a .vmt."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
		4 : "strict remove after lifetime" : 0
	]

	nogibshadows(choices) :"Disable Shadows on Gibs" : 0 =
	[
		0: "No"
		1: "Yes"
	]

	gibgravityscale(float) : "Gib gravity scale" : "1" : "ONLY WORKS FOR POINT GIBS. This field allows you to scale gravity so that gibs fall faster, slower, or not at all."
	
	massoverride(float) : "Mass override" : "0" : "EPISODIC ONLY. Specify an arbitrary mass for the gibs emitted by me."
]

@PointClass base(gibshooterbase, RenderFields) = env_rotorshooter : 
	"An entity that creates gibs when it's within the influence of a helicopter's rotor wash."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out.  Can be a .mdl or a .vmt."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
	]

	rotortime(float) : "Time Under Rotor" : "1" : "The average time it has to be under the rotor before it shoots a gib."
	rotortimevariance(float) : "Time variance" : "0.3" : "The random amount to vary the time it has to be under the rotor before it shoots a gib."
]

@PointClass base(Targetname,Parentname) = env_soundscape_proxy : 
	"An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity."
[
	MainSoundscapeName(target_destination) : "Soundscape Entity" : "" : "The soundscape to get all sound parameters from."
	radius(integer) : "Radius" : 128
]

@PointClass base(Targetname,Parentname,EnableDisable) = env_soundscape : 
	"An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius."
[
	radius(integer) : "Radius" : 128 : "If set to -1, then the player can hear the soundscape as long as he can see it (regardless of distance to it)."
	soundscape(choices) : "Soundscape" : "Nothing" : "The name of the soundscape to use. Corresponds to an entry in the soundscapes*.txt file in the hl2\scripts directory." =
	[
		"Nothing" : "Nothing"
		"Automatic" : "Automatic"
		"Automatic_Dialog" : "Automatic (dialog)"
		"GenericIndoor" : "Indoor"
		"GenericOutdoor" : "Outdoor"
	]
	position0(target_destination) : "Sound Position 0" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position1(target_destination) : "Sound Position 1" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position2(target_destination) : "Sound Position 2" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position3(target_destination) : "Sound Position 3" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position4(target_destination) : "Sound Position 4" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position5(target_destination) : "Sound Position 5" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position6(target_destination) : "Sound Position 6" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position7(target_destination) : "Sound Position 7" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
]

@PointClass base(env_soundscape) = env_soundscape_triggerable : 
	"An entity that works like env_soundscape except that it works in conjunction with trigger_soundscape to determine when a player hears it." []

@PointClass base(Targetname, Parentname, Angles) = env_spark : 
	"An entity used to create sparks at its origin." 
[
	MaxDelay(string) : "Max Delay" : "0" : "The longest delay between sparks (in seconds)."
	Magnitude(choices) : "Magnitude" : 1 : "The size of the sparks." =
	[
		1 : "Small"
		2 : "Medium"
		5 : "Large"
		8 : "Huge"
	]

	TrailLength(choices) : "Spark Trail Length" : 1 =
	[
		1 : "Short"
		2 : "Medium"
		3 : "Long"
	]

	spawnflags(flags) =
	[
		64: "Start ON" : 0
		128: "Glow" : 0
		256: "Silent" : 0
		512: "Directional" : 0
	]
]

@PointClass base(Targetname, Parentname, RenderFields,DXLevelChoice) size(-2 -2 -2, 2 2 2) color(20 140 20) = env_sprite : 
	"An entity that controls the drawing of a sprite in the world." 
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "Start on" : 0
		2: "Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
]

@PointClass base(env_sprite, Angles) = env_sprite_oriented :
	"A env_sprite that allows orientation."
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "Start on" : 0
		2: "Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
]


@PointClass base(Targetname, Angles) = env_wind : 
	"An entity to control wind in the map. Partially functional."
[
	//gustsound(sound) : "Gust Sound Filename" : "" : "Sound to be played to simulate the gusting wind."
	minwind(integer) : "Min normal speed" : 20 : "Minimum speed of the wind while idling."
	maxwind(integer) : "Max normal speed" : 50 : "Maximum speed of the wind while idling."

	mingust(integer) : "Min gust speed" : 100 : "Minimum speed of wind gusts."
	maxgust(integer) : "Max gust speed" : 250 : "Maximum speed of wind gusts."

	mingustdelay(integer) : "Min gust delay" : 10 : "Minimum time delay between random gusts."
	maxgustdelay(integer) : "Max gust delay" : 20 : "Maximum time delay between random gusts."

	gustduration(integer) : "Gust Duration" : 5 : "How long will the wind gust for."

	gustdirchange(integer) : "Max gust dir change (degrees)" : 20 : "Maximum amount that the wind's direction changes due to a gust."
]

@PointClass base(Targetname, Parentname, Angles) size(-16 -16 -16, 16 16 16) color(0 0 255) = sky_camera : 
	"An entity used to control the 3D Skybox. Its origin is used to determine the 3D Skybox's position relative to the map. Place this entity, in the 3D Skybox, at the point where the origin of the map should be."
[
	parentname(target_destination) : "Parent" : : "The name of the entity to move with. NOTE: sky_camera's position is normally only updated on spawn. Fire the ForceUpdate or StartUpdating inputs to update the sky_camera's position! You might also want to enable Use Angles for Sky."
	
	spawnflags(flags) =
	[
		1: "Master (takes priority if multiple sky_cameras exist)" : 0
		2: "Continuously update position (for moving sky_cameras)" : 0
	]
	
	skycolor(color255) : "Sky Color" : "255 255 255 0" : "Causes the skybox to use a solid color instead of the sky texture specified in worldspawn. Blended alpha is unfortunately not supported, but an alpha of '0' disables the effect and any alpha greater than that (e.g. 255) enables the effect."

	scale(integer) : "3D Skybox scale" : 16 : "Scale of the skybox."
	fogenable(choices) : "Fog Enable" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	fogblend(choices) : "Fog Blend" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles(choices) : "Use Angles for Fog Dir" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	use_angles_for_sky(choices) : "Use Angles for Sky" : 0 : "Uses angles for actual skybox rotation, as if the world were tilted on this entity's axis." =
	[
		0 : "No"
		1 : "Yes"
	]
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Dir" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0" : "Distance at which the skybox fog should start."
	fogend(string) : "Fog End" : "2000.0" : "Distance at which the skybox fog should be fully opaque."
	fogmaxdensity(float) : "Fog Max Density [0..1]" : "1"
	
	farz(float) : "Far Z Clip Plane" : "0" : "Clips the sky."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = skybox_swapper : 
	"An entity that swaps skybox textures." 
[
	SkyboxName(string) : "Sky Name" : "" : "The name of the sky texture to change to."
]

@BaseClass base(Targetname, ResponseContext) = BaseSpeaker
[
	delaymin(string) : "Min Delay Between Announcements" : "15"
	delaymax(string) : "Max Delay Between Announcements" : "135"
	spawnflags(flags) =
	[
		1: "Start Silent" : 0
		2: "Play Everywhere" : 0
	]
	rulescript(string) : "Context rule script" : "" : "Script file containing rules for playing appropriate sounds."
	concept(string) : "Concept name" : "" : "High level concept name used as primary search key."
]





//////////////////////////////////////////////////////
//
// point entities
//
//////////////////////////////////////////////////////

@PointClass base(Targetname, Parentname) = func_useableladder : 
	"A Half-Life 2 ladder. Handles player auto mount/unmount, as well as +use to get onto the ladder. \n\n" +
	"See also 'info_ladder_dismount', used to specify ladder auto-dismount points.\n\n" +
	"Note: This entity is non-functional in Counter-Strike: Source. Use func_ladder instead."
[
	spawnflags(flags) =
	[
		1: "Fake Ladder" : 0
	]

	point0(vector) : "Start" : : "Ladder end point."
	point1(vector) : "End" : : "Ladder end point."

	StartDisabled(choices) : "Start Disabled" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname, Parentname, Angles) size( -16 -16 0, 16 16 72 ) color(127 127 127) = func_ladderendpoint : 
	"An entity used to specify the endpoints of a ladder. This entity is functional, but has been replaced by the " + 
	"easier-to-use func_useableladder entity. Left in only for backwards-compatibility! " +
	"To be valid, a full sized player hull traced between the start and end points must not be obstructed at level " + 
	"activation time. The angle determines in which direction the player leaves the ladder if the player presses the " +
	"+jump button. " +
	"Note: This entity is non-functional in Counter-Strike: Source. In CS:S, use func_ladder instead."
[
	target(string) : "Other" : : "A ladder goes between any two func_ladderendpoints pointing at each other."
]

@PointClass base(Parentname) size( -16 -16 0, 16 16 4 ) color(255 128 255)= info_ladder_dismount : 
	"An entity to handle endpoints for multiple ladders that are too close to each other."
[
	target(string) : "LadderName" : : "If multiple ladders are near multiple endpoints, use this to stop them from interfering with each other."
]
	
@PointClass base(Targetname) = infodecal : 
	"An entity that places a decal on the world. If the decal has no target name, it will immediately apply itself when the level is loaded. "+
	"If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	texture(decal)

	LowPriority(choices) : "Low Priority (can be replaced)" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

// A decal to be applied to a prop or the world using specified origin and orientation and radius, uses an orientation angle and a radius to determine
//  ray to cast for projection
@PointClass base(Angles, Targetname) = info_projecteddecal : 
	"An entity that projects a decal onto the world (or props). If the decal has no target name, it will immediately apply itself when "+
	"the level is loaded. If it has a name specified, it won't apply until it receives the 'Activate' input."
[
	texture(decal)
	Distance(float) : "Distance" : "64" : "Distance from the origin to project the decal."
]

@PointClass = info_no_dynamic_shadow : 
	"Use this entity to mark surfaces that shouldn't receive dynamic shadows. Useful to apply to walls and floors "+
	"where shadows are drawn improperly, giving away the location of enemies."
[
	sides(sidelist) : "Brush faces"
]

@PointClass base(PlayerClass, Angles) = info_player_start :
	"This entity indicates the position and facing direction at which the player will spawn. Any number of "+
	"info_player_start entities may be placed in a map for when working in cordoned-off portions of the map. "+
	"When multiple info_player_start entities are present in a map, set the 'Master' spawnflag on one of them "+
	"to indicate which one should be used when running the entire map."
[
	spawnflags(flags) =
	[
		1: "Master (Has priority if multiple info_player_starts exist)" : 0
	]
]

@PointClass base(Targetname) size(-1 -1 0, 1 1 1) color(80 150 225) = info_overlay : 
	"An entity that places an overlay on the world." 
[
	material(material) : "Material"
	sides(sidelist) : "Brush faces"
	RenderOrder(integer) : "Render Order" : 0 : "Higher values render after lower values. This value can be 0-3."
	StartU(float) : "U Start" : "0.0"
	EndU(float) : "U End" : "1.0"
	StartV(float) : "V Start" : "0.0"
	EndV(float) : "V End" : "1.0"
	BasisOrigin(Vector) readonly : "Overlay Basis Origin(Read-Only)"
	BasisU(Vector) readonly : "Overlay Basis U(Read-Only)"
	BasisV(Vector) readonly : "Overlay Basis V(Read-Only)"
	BasisNormal(Vector) readonly : "Overlay Basis Normal(Read-Only)"
	uv0(vector) readonly : "Overlay Point 1(Read-Only)"
	uv1(vector) readonly : "Overlay Point 2(Read-Only)"
	uv2(vector) readonly : "Overlay Point 3(Read-Only)"
	uv3(vector) readonly : "Overlay Point 4(Read-Only)"
	fademindist(float) : "Start Fade Dist" : "-1" : "Distance at which the overlay starts to fade (<0 = use fademaxdist)."
	fademaxdist(float) : "End Fade Dist" : "0" : "Maximum distance at which the overlay is visible (0 = don't fade out)."
]

@PointClass size(-8 -8 -8, 8 8 8) = info_overlay_transition : "Overlay Transition" 
[
	material(material) : "Material"
	sides(sidelist) : "Brush faces"
	sides2(sidelist) : "Water faces"
	LengthTexcoordStart(float) : "Texcoord Length Start" : "0.0"
	LengthTexcoordEnd(float) : "Texcoord Length End" : "1.0"
	WidthTexcoordStart(float) : "Texcoord Width Start" : "0.0"
	WidthTexcoordEnd(float) : "Texcoord Width End" : "1.0"
	Width1(float) : "Width Land" : "25.0"
	Width2(float) : "Width Water" : "25.0"
	DebugDraw(integer) : "Show Debug" : 0 : "Boolean value (0 or 1)."
]

@PointClass size(-4 -4 -4, 4 4 4) color(0 180 0) = info_intermission : 
	"An entity that defines an intermission spot where dead players will float until they respawn."
[
	target(target_destination) : "Entity to look at" : : "Name of entity that dead players will face while in intermission at this spot."
]

@PointClass base(Targetname, Parentname, Angles) = info_landmark : 
	"An entity that acts as a landmark for transitions to another level. There should be a corresponding info_landmark entity in the next map. Entities will be transitioned to the next level relative to the info_landmark entities." []

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = info_null : 
	"An entity that's immediately removed on spawning. Useful as a spotlight target." []

@PointClass base(Targetname, Parentname, Angles) = info_target : 
	"An entity that does nothing. Very useful as a positioning entity for other entities to refer to (i.e. the endpoint of an env_beam)"
[
	spawnflags( Flags ) =
	[
		1 : "Transmit to client" : 0
	]
]

@PointClass base(Targetname, Parentname, Angles) = info_particle_system : 
	"An entity that spawns a particle system built using the particle editor."
[
	effect_name(string) : "Particle System Name"
	duration(float) : "Particle System Duration" : "0.0" : "The duration of this particle system, 0.0 is infinite"
	start_active(choices) : "Start Active?" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	attach_to_player(choices) : "Attach to Player" : 0 : "If set, the particle effect starts on the player" =
	[
		0 : "No"
		1 : "Yes"
	]
	flag_as_weather(choices) : "Flag as Weather?" : 0 : "Is this particle system going to be used as a weather effect?" =
	[
		0 : "No"
		1 : "Yes"
	]
	
	cpoint1(target_destination) : "Control Point 1" : : "If set, control point 1 of the effect will be at this entity's location."
	cpoint2(target_destination) : "Control Point 2" : : "If set, control point 2 of the effect will be at this entity's location. If control point 1 is not set, this will be ignored."
	cpoint3(target_destination) : "Control Point 3" : : "If set, control point 3 of the effect will be at this entity's location. If control point 2 is not set, this will be ignored."
	cpoint4(target_destination) : "Control Point 4" : : "If set, control point 4 of the effect will be at this entity's location. If control point 3 is not set, this will be ignored."
	cpoint5(target_destination) : "Control Point 5" : : "If set, control point 5 of the effect will be at this entity's location. If control point 4 is not set, this will be ignored."
	cpoint6(target_destination) : "Control Point 6" : : "If set, control point 6 of the effect will be at this entity's location. If control point 5 is not set, this will be ignored."
	cpoint7(target_destination) : "Control Point 7" : : "If set, control point 7 of the effect will be at this entity's location. If control point 6 is not set, this will be ignored."
	cpoint8(target_destination) : "Control Point 8" : : "If set, control point 8 of the effect will be at this entity's location. If control point 7 is not set, this will be ignored."
	cpoint9(target_destination) : "Control Point 9" : : "If set, control point 9 of the effect will be at this entity's location. If control point 8 is not set, this will be ignored."
	cpoint10(target_destination) : "Control Point 10" : : "If set, control point 10 of the effect will be at this entity's location. If control point 9 is not set, this will be ignored."
	cpoint11(target_destination) : "Control Point 11" : : "If set, control point 11 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint12(target_destination) : "Control Point 12" : : "If set, control point 12 of the effect will be at this entity's location. If control point 11 is not set, this will be ignored."
	cpoint13(target_destination) : "Control Point 13" : : "If set, control point 13 of the effect will be at this entity's location. If control point 12 is not set, this will be ignored."
	cpoint14(target_destination) : "Control Point 14" : : "If set, control point 14 of the effect will be at this entity's location. If control point 13 is not set, this will be ignored."
	cpoint15(target_destination) : "Control Point 15" : : "If set, control point 15 of the effect will be at this entity's location. If control point 14 is not set, this will be ignored."
	cpoint16(target_destination) : "Control Point 16" : : "If set, control point 16 of the effect will be at this entity's location. If control point 15 is not set, this will be ignored."
	cpoint17(target_destination) : "Control Point 17" : : "If set, control point 17 of the effect will be at this entity's location. If control point 16 is not set, this will be ignored."
	cpoint18(target_destination) : "Control Point 18" : : "If set, control point 18 of the effect will be at this entity's location. If control point 17 is not set, this will be ignored."
	cpoint19(target_destination) : "Control Point 19" : : "If set, control point 19 of the effect will be at this entity's location. If control point 18 is not set, this will be ignored."
	cpoint20(target_destination) : "Control Point 20" : : "If set, control point 20 of the effect will be at this entity's location. If control point 19 is not set, this will be ignored."
	cpoint21(target_destination) : "Control Point 21" : : "If set, control point 21 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint22(target_destination) : "Control Point 22" : : "If set, control point 22 of the effect will be at this entity's location. If control point 21 is not set, this will be ignored."
	cpoint23(target_destination) : "Control Point 23" : : "If set, control point 23 of the effect will be at this entity's location. If control point 22 is not set, this will be ignored."
	cpoint24(target_destination) : "Control Point 24" : : "If set, control point 24 of the effect will be at this entity's location. If control point 23 is not set, this will be ignored."
	cpoint25(target_destination) : "Control Point 25" : : "If set, control point 25 of the effect will be at this entity's location. If control point 24 is not set, this will be ignored."
	cpoint26(target_destination) : "Control Point 26" : : "If set, control point 26 of the effect will be at this entity's location. If control point 25 is not set, this will be ignored."
	cpoint27(target_destination) : "Control Point 27" : : "If set, control point 27 of the effect will be at this entity's location. If control point 26 is not set, this will be ignored."
	cpoint28(target_destination) : "Control Point 28" : : "If set, control point 28 of the effect will be at this entity's location. If control point 27 is not set, this will be ignored."
	cpoint29(target_destination) : "Control Point 29" : : "If set, control point 29 of the effect will be at this entity's location. If control point 28 is not set, this will be ignored."
	cpoint30(target_destination) : "Control Point 30" : : "If set, control point 30 of the effect will be at this entity's location. If control point 29 is not set, this will be ignored."
	cpoint31(target_destination) : "Control Point 31" : : "If set, control point 31 of the effect will be at this entity's location. If control point 30 is not set, this will be ignored."
	cpoint32(target_destination) : "Control Point 32" : : "If set, control point 32 of the effect will be at this entity's location. If control point 31 is not set, this will be ignored."
	cpoint33(target_destination) : "Control Point 33" : : "If set, control point 33 of the effect will be at this entity's location. If control point 32 is not set, this will be ignored."
	cpoint34(target_destination) : "Control Point 34" : : "If set, control point 34 of the effect will be at this entity's location. If control point 33 is not set, this will be ignored."
	cpoint35(target_destination) : "Control Point 35" : : "If set, control point 35 of the effect will be at this entity's location. If control point 34 is not set, this will be ignored."
	cpoint36(target_destination) : "Control Point 36" : : "If set, control point 36 of the effect will be at this entity's location. If control point 35 is not set, this will be ignored."
	cpoint37(target_destination) : "Control Point 37" : : "If set, control point 37 of the effect will be at this entity's location. If control point 36 is not set, this will be ignored."
	cpoint38(target_destination) : "Control Point 38" : : "If set, control point 38 of the effect will be at this entity's location. If control point 37 is not set, this will be ignored."
	cpoint39(target_destination) : "Control Point 39" : : "If set, control point 39 of the effect will be at this entity's location. If control point 38 is not set, this will be ignored."
	cpoint40(target_destination) : "Control Point 40" : : "If set, control point 40 of the effect will be at this entity's location. If control point 39 is not set, this will be ignored."
	cpoint41(target_destination) : "Control Point 41" : : "If set, control point 41 of the effect will be at this entity's location. If control point 40 is not set, this will be ignored."
	cpoint42(target_destination) : "Control Point 42" : : "If set, control point 42 of the effect will be at this entity's location. If control point 41 is not set, this will be ignored."
	cpoint43(target_destination) : "Control Point 43" : : "If set, control point 43 of the effect will be at this entity's location. If control point 42 is not set, this will be ignored."
	cpoint44(target_destination) : "Control Point 44" : : "If set, control point 44 of the effect will be at this entity's location. If control point 43 is not set, this will be ignored."
	cpoint45(target_destination) : "Control Point 45" : : "If set, control point 45 of the effect will be at this entity's location. If control point 44 is not set, this will be ignored."
	cpoint46(target_destination) : "Control Point 46" : : "If set, control point 46 of the effect will be at this entity's location. If control point 45 is not set, this will be ignored."
	cpoint47(target_destination) : "Control Point 47" : : "If set, control point 47 of the effect will be at this entity's location. If control point 46 is not set, this will be ignored."
	cpoint48(target_destination) : "Control Point 48" : : "If set, control point 48 of the effect will be at this entity's location. If control point 47 is not set, this will be ignored."
	cpoint49(target_destination) : "Control Point 49" : : "If set, control point 49 of the effect will be at this entity's location. If control point 48 is not set, this will be ignored."
	cpoint50(target_destination) : "Control Point 50" : : "If set, control point 50 of the effect will be at this entity's location. If control point 49 is not set, this will be ignored."
	cpoint51(target_destination) : "Control Point 51" : : "If set, control point 51 of the effect will be at this entity's location. If control point 50 is not set, this will be ignored."
	cpoint52(target_destination) : "Control Point 52" : : "If set, control point 52 of the effect will be at this entity's location. If control point 51 is not set, this will be ignored."
	cpoint53(target_destination) : "Control Point 53" : : "If set, control point 53 of the effect will be at this entity's location. If control point 52 is not set, this will be ignored."
	cpoint54(target_destination) : "Control Point 54" : : "If set, control point 54 of the effect will be at this entity's location. If control point 53 is not set, this will be ignored."
	cpoint55(target_destination) : "Control Point 55" : : "If set, control point 55 of the effect will be at this entity's location. If control point 54 is not set, this will be ignored."
	cpoint56(target_destination) : "Control Point 56" : : "If set, control point 56 of the effect will be at this entity's location. If control point 55 is not set, this will be ignored."
	cpoint57(target_destination) : "Control Point 57" : : "If set, control point 57 of the effect will be at this entity's location. If control point 56 is not set, this will be ignored."
	cpoint58(target_destination) : "Control Point 58" : : "If set, control point 58 of the effect will be at this entity's location. If control point 57 is not set, this will be ignored."
	cpoint59(target_destination) : "Control Point 59" : : "If set, control point 59 of the effect will be at this entity's location. If control point 58 is not set, this will be ignored."
	cpoint60(target_destination) : "Control Point 60" : : "If set, control point 60 of the effect will be at this entity's location. If control point 59 is not set, this will be ignored."
	cpoint61(target_destination) : "Control Point 61" : : "If set, control point 61 of the effect will be at this entity's location. If control point 60 is not set, this will be ignored."
	cpoint62(target_destination) : "Control Point 62" : : "If set, control point 62 of the effect will be at this entity's location. If control point 61 is not set, this will be ignored."
	cpoint63(target_destination) : "Control Point 63" : : "If set, control point 63 of the effect will be at this entity's location. If control point 62 is not set, this will be ignored."
	
	cpoint1_parent(integer) : "Control Point 1's Parent" : 0 : "If set and nonzero, control point 1 of the effect will use this point for its parent."
	cpoint2_parent(integer) : "Control Point 2's Parent" : 0 : "If set and nonzero, control point 2 of the effect will use this point for its parent."
	cpoint3_parent(integer) : "Control Point 3's Parent" : 0 : "If set and nonzero, control point 3 of the effect will use this point for its parent."
	cpoint4_parent(integer) : "Control Point 4's Parent" : 0 : "If set and nonzero, control point 4 of the effect will use this point for its parent."
	cpoint5_parent(integer) : "Control Point 5's Parent" : 0 : "If set and nonzero, control point 5 of the effect will use this point for its parent."
	cpoint6_parent(integer) : "Control Point 6's Parent" : 0 : "If set and nonzero, control point 6 of the effect will use this point for its parent."
	cpoint7_parent(integer) : "Control Point 7's Parent" : 0 : "If set and nonzero, control point 7 of the effect will use this point for its parent."
]


@PointClass base(Targetname, EnableDisable, Parentname, Angles) = phys_ragdollmagnet : 
	"An entity that acts like a magnet for ragdolls. Useful for crafting exaggerated ragdoll behavior (i.e. guys falling over rails on death). If the "+
	"Bar Magnet spawnflag is set, the magnet works like it was a cylindrical magnet i.e. it attracts ragdolls to the nearest point on a line."
[
	axis(vecline) : "Bar Magnet Axis"
	radius(float) : "Effective Radius" : "512" : "Radius in which ragdolls are affected around this entity's origin."
	force(float) : "Force" : "5000" : "Magnetic force to apply to ragdolls within the radius. Expressed as kilograms per inch per second. So a force of 1000 will add 10 inches/second to a 100kg man. It will add 100 inches per second to a 10kg headcrab."

	target(string) : "Entity to affect" : "" : "If specified, the phys_ragdollmagnet will only affect the target entity."

	spawnflags( Flags ) =
	[
		2 : "Bar Magnet (use axis helper)" : 0
	]
]

@PointClass base(Targetname) = info_lighting : 
	"An entity that can be used to change the lighting origin of a prop_static. Set the prop_static's Lighting Origin to point at this entity to "+
	"make the prop_static light as if it was at the info_lighting's origin. Good for prop_static entities that are embedded in world geometry (like rocks/windows/etc)." []

// This is obsolete, info_target is all you need now.
@PointClass base(Targetname, Parentname, Angles, PlayerClass) = info_teleport_destination : 
	"An entity that does nothing itself, but can be used to specify the destination for a trigger_teleport entity. An info_target can be used instead." []

@PointClass base(Targetname, Parentname, EnableDisable) = point_anglesensor :
	"An entity that detects if another entity points in a given direction for a period of time."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."
	lookatname(target_destination) : "Look At Entity" : : "The entity we want to check to see if the Target Entity is looking at."
	duration(float) : "Duration" : : "The amount of time the Target Entity must look at the 'Look at Entity' to trigger this entity, in seconds."
	tolerance(integer) : "Tolerance" : : "The tolerance, in degrees, in the checking to determine when the Target Entity is looking at the Look At Entity."

	spawnflags(Flags) =
	[
		1 : "Use target entity's angles (NOT position)" : 0
	]
]

@PointClass base(Targetname) = point_angularvelocitysensor :
	"An entity that detects if another entity's angular velocity meets or exceeds a threshold value."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angular velocity will be sensed."
	threshold(float) : "Threshold Velocity" : "0" : "The threshold angular velocity to compare against, in degrees per second."
	fireinterval(float) : "Fire Interval" : "0.2" : "Angular velocity must cross the threshold for at least this long to fire."

	axis(vecline) : "Axis"

	usehelper(choices) : "Use Axis Helper" : 0 : "Use axis helper to determine rotation values (clockwise/counter-clockwise)." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = point_velocitysensor :
	"An entity that detects and outputs an entity's velocity."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose velocity will be sensed."
	axis(vecline) : "Measurement Axis"
	enabled(choices) : "Start Enabled" : 1 : "Whether or not to start enabled and active." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname, Parentname, EnableDisable, Angles) = point_proximity_sensor :
	"An entity that detects another entity's proximity to a target position."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."

	spawnflags(Flags) =
	[
		1 : "Test the distance as measured along the axis specified by our direction." : 0
	]
]


@PointClass base(Targetname, Angles) = point_teleport : 
	"An entity that teleports a target entity to this position and angles. "+
	"If 'Teleport Home' spawn flag is set, teleports the target entity to its spawn position instead." +
	"If object is physically simulated, simulation is turned off when teleported."
[
	target(target_destination) : "Entity To Teleport" : : "Name of the entity that will be teleported."
	spawnflags(flags) =
	[
		1 : "Teleport Home" : 0
		2 : "Into Duck (episodic)" : 0
	]
]

@PointClass base(Targetname) = point_hurt :
	"An entity that does damage to all entities in a radius around itself, with a specified delay." +
	"If 'Target Entity' is specified, the damage is only done to that entity."
[
	DamageTarget(string) : "Target Entity" : "" : "If specified, only this entity will take damage. Otherwise, all entities within the Radius will take damage."
	
	DamageRadius(float) : "Radius" : "256" : "All entities within this radius of this entity will take damage. If a 'Target Entity' is specified, only that entity will take damage."
	Damage(integer) : "Damage" : 5 : "Damage done to all affected entities each time this entity fires."
	DamageDelay(float) : "Delay" : "1" : "Delay between refires, in seconds."
	
	DamageType(choices) : "Damage Type" : 0 : "Type of damage to inflict on entities damaged." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_playermoveconstraint : 
	"An entity that constrains players to a radius around itself, slowing them down the closer they get to the edge of the radius."
[
	radius(float) : "Radius" : "256" : "Radius to constrain players to."
	width(float) : "Constraint Width" : "75.0" : "Width of the constraint edge. This is the distance in which to start slowing players down as they approach the edge of the radius."
	speedfactor(float) : "Speed Factor" : "0.15" : "Factor applied to the player's max speed as they approach the radius edge."
]





//////////////////////////////////////////////////////
//
// lights
//
//////////////////////////////////////////////////////

@PointClass base(Targetname, Light) = light :
	"An invisible omnidirectional lightsource."
[
	target(target_destination) : "Entity To Point At" : : "The name of an entity in the map that the spotlight will point at. This will override the spotlight's angles."
	spawnflags(Flags) = [ 1 : "Initially dark" : 0 ]
	_distance(integer) : "Maximum Distance" : 0 : "This is the distance that light is allowed to cast, in inches."
]

@PointClass base(Angles) = light_environment : 
	"Sets the color and angle of the light from the sun and sky."
[
	_light(color255) : "Brightness" : "255 255 255 200"
	_ambient(color255) : "Ambient" : "255 255 255 20"
	_lightHDR(color255) : "BrightnessHDR" : "-1 -1 -1 1"
	_lightscaleHDR(float) : "BrightnessScaleHDR" : "1" : "Amount to scale the light by when compiling for HDR."
	_ambientHDR(color255) : "AmbientHDR" : "-1 -1 -1 1"
	_AmbientScaleHDR(float) : "AmbientScaleHDR" : "1" : "Amount to scale the ambient light by when compiling for hdr."
	pitch(integer) : "Pitch" : 0 : "The downward pitch of the light from the sun. 0 is horizontal, -90 is straight down."
	SunSpreadAngle(float) : "SunSpreadAngle" : "0" : "The angular extent of the sun for casting soft shadows. Higher numbers are more diffuse. 5 is a good starting value."
]

@PointClass base(Targetname, Angles, Light) = light_spot :
	"An invisible and directional spotlight."
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the spotlight will point at. This will override the spotlight's angles."
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	_exponent(integer) : "Focus" : 1
	_distance(integer) : "Maximum distance" : 0 : "This is the distance that light is allowed to cast, in inches."
	pitch(integer) : "Pitch" : -90
	spawnflags(Flags) = [ 1 : "Initially dark" : 0 ]
]

@PointClass base(Targetname, Parentname, Angles) size(-4 -4 -4, 4 4 4) = light_dynamic : 
	"An invisible lightsource that changes in some way over time." 
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the dynamic light will point at."
	_light(color255) : "Light color" : "255 255 255 200"
	brightness(integer) : "Light brightness" : 0
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	pitch(integer) : "Pitch" : -90
	distance(float) : "Maximum distance" : "120" : "This is the distance that light is allowed to cast, in inches."
	spotlight_radius(float) : "Spotlight end radius" : "80" : "This is the radius of the light, in inches, at the object that it is hitting."
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	spawnflags(Flags) = 
	[ 
		1 : "Do not light world (better perf)" : 0 
		2 : "Do not light models" : 0
		4 : "Add Displacement Alpha" : 0
		8 : "Subtract Displacement Alpha" : 0
	]
]

// Beam spotlight ---------------------
@PointClass base(Targetname, Parentname, RenderFields, Angles, DXLevelChoice) = beam_spotlight : 
	"An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. "+
	"Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests." +
	"This spotlight is entirely client side, it is not sync'd across clients."
[
	spawnflags(Flags) = 
	[
		1 : "Start On" : 1
		2 : "No Dynamic Light" : 0
		4 : "Start rotation on" : 0
		8 : "Reverse Direction" : 0
		16 : "X Axis"  : 0
		32 : "Y Axis"  : 0
	]

	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the spotlight, in degrees per second."

	spotlightlength(integer) : "Spotlight Length" : 500 : "Length of the spotlight beam."
	spotlightwidth(integer) : "Spotlight Width" : 50 : "Width of the spotlight beam."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	HDRColorScale(float) : "HDR color scale." : "0.7" : "float value to multiply sprite color by when running in HDR mode."
]

//-------------------------------------------------------------------------
// Shadow control
//-------------------------------------------------------------------------

@PointClass base(Targetname) = shadow_control : 
	"An entity to control the shadows in the map."
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "80 30 0" : "This is the shadow direction. Pitch is rotation around the Y axis, yaw is the rotation around the Z axis, and roll is the rotation around the X axis."

	color(color255) : "Shadow Color" : "128 128 128" : "This is the color of the shadows."
	distance(float) : "Maximum Distance" : "75" : "This is the maximum distance the shadow is allowed to cast, in inches."
	disableallshadows(Choices) : "All Shadows Disabled" : 0 = 
	[
		0 : "No"
		1 : "Yes"
	]
]


//-------------------------------------------------------------------------
// Color correction control
//-------------------------------------------------------------------------

@PointClass base(Targetname, EnableDisable) = color_correction : 
	"An entity to control the color correction in the map."
[
	minfalloff(float) : "Lookup Falloff Start Distance" : "0.0" : "This is the distance to the start of the falloff region (-1 = everywhere)"
	maxfalloff(float) : "Lookup Falloff End Distance" : "200.0" : "This is the distance to the end of the falloff region (-1 = everywhere)"
	maxweight(float) : "Maximum Weight" : "1.0"   : "This is the maximum weight for this lookup"
	filename(string) : "Lookup Table Filename" : ""	  : "This is the lookup table filename"
	fadeInDuration(float) : "Lookup Fade In Duration" : "0.0" : "Duration of fade in on when enabled."
	fadeOutDuration(float) : "Lookup Fade out Duration" : "0.0" : "Dration of fade out on when disabled."
]


//-------------------------------------------------------------------------
// Color correction volume control
//-------------------------------------------------------------------------

@SolidClass base(Targetname, EnableDisable ) = color_correction_volume : 
	"An entity to control the color correction in the map."
[
	fadeDuration(float) : "Lookup Fade Duration" : "10.0" : "This is the duration for the lookup to fade in/out on extry/exit"
	maxweight(float) : "Maximum Weight" : "1.0" : "This is the maximum weight for this lookup"
	filename(string) : "Lookup Table Filename" : ""	 : "This is the lookup table filename"
]





//////////////////////////////////////////////////////
//
// solid entities
//
//////////////////////////////////////////////////////

@SolidClass base(Targetname) color(0 255 255) = func_areaportal :
	"A portal brush used to manage visibility in maps. Portals define areas, which are spaces " +
	"that are connected in the map. Both sides of a portal cannot touch the same area, for example, a " +
	"doughnut shaped map would require at least two portals to divide the map into two areas. A linear map " +
	"could be divided into two areas with a single area portal."
[
	target(target_destination) : "Name of Linked Door" : : "(Optional) The name of a door whose open/closed state controls the on/off state of this area portal."
	StartOpen(choices) : "Initial State" : 1 =
	[
		0 : "Closed"
		1 : "Open"
	]

	PortalVersion(integer) : "Portal Version" : 1 : "(Don't change). Differentiates between shipping HL2 maps and maps using new engine features."
]

@SolidClass base(Targetname) color(0 255 255) = func_occluder :
	"A occluder brush used to manage dynamic visibility in maps. Occluders are used to dynamically " +
	"determine what things are behind them, to prevent trying to draw them at all."
[
	StartActive(choices) : "Initial State" : 1 =
	[
		0 : "Inactive"
		1 : "Active"
	]
]

@SolidClass base(BreakableBrush, RenderFields, Shadow) = func_breakable : 
	"A brush entity that can be broken from damage, or an input." 
[
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	physdamagescale(float) : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
]

@SolidClass base(BreakableBrush, RenderFields, Shadow) = func_breakable_surf : 
	"A breakable surface, for partially breakable glass / tile / etc.  All faces but the desired visible one must be marked as NODRAW and that" +
	"face must be 4 sided.  The material applied to the visible face must be set up to be breakable." 
[
	spawnflags(Flags) = 
	[
		1 : "Physics damage decals" : 0
		2 : "Take damage from held objects" : 0
	]
	health(integer) : "Health" : 5 : "The amount of damage the surface takes before breaking."
	fragility(integer) : "Fragility" : 100 : "If the 'Surface Type' is set to Glass, this value sets how fragile the glass pieces are after the surface has been broken."
	surfacetype(choices) : "Surface Type" : 0 = 
	[
		0 : "Glass"
		1 : "Tile"
	
	]
]

@SolidClass color(180 180 0) = func_viscluster : 
	"Any leaves touching this brush will have their vis merged together into a single cluster.  Use multiple func_viscluster entities to reduce vis time" []

@SolidClass base(Targetname, Parentname) = func_precipitation : 
	"A brush entity that creates rain and snow inside its volume."
[
	renderamt(integer) : "Density (0-100%)" : 5	
	rendercolor(color255) : "Color (R G B)" : "100 100 100"
	preciptype(choices) : "Precipitation Type" : 0 =	
	[
		0 : "Rain"
		1 : "Snow"
		2 : "Ash"
		3 : "Snowfall"
	]
]

@SolidClass base(Targetname, Parentname, RenderFields, Global) = func_guntarget :
	"This is a moving target that moves along a path of path_tracks. It can be shot and killed."
[
	speed(integer) : "Speed (units per second)" : 100 : "The speed at which the target moves along its path."
	target(target_destination) : "First stop target" : : "The name of the first path_track entity in the path that this target should follow."
	health(integer) : "Damage to Take" : 0 : "The amount of damage taken before this target is killed."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@PointClass = func_fish_pool : "Creates a school of interactive fish that swim near this entity."
[
	model(studio) : "World model" : "models/Junkola.mdl"
	fish_count(integer) : "Fish Count" : 10 : "Number of Fish in this Pool"
	max_range(float) : "Max Range" : "150" : "How far away a Fish can wander (max 255)"
]

@SolidClass base(Targetname, Parentname, RenderFields, Shadow) = func_conveyor : 
	"Conveyor Belt"			// NEEDHELP
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction conveyor moves."
	spawnflags(flags) =
	[
		1 : "No Push" : 0
		2 : "Not Solid" : 0
	]
	speed(float) : "Conveyor Speed" : "100.0"
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname) color(0 128 255) = func_areaportalwindow : 
	"An entity that can be used to optimize the visibility in a map. If you seal off an area with them, when the viewer moves the specified distance away from them, they will go opaque and the parts inside the area will not be drawn. The 'target' brush model should enclose the func_areaportal window so no parts of it are culled by the window. If you use the optional foreground brush model, then it should enclose the 'target' brush model."
[
	target(string) : "Rendered Window" : : "The name of a brush model to render as the window."
	FadeStartDist(integer) : "Fade Start Distance" : 128 : "When the viewer is closer than this distance, the alpha is set to 'TranslucencyLimit'."
	FadeDist(integer) : "Fade End Distance" : 512 : "When the viewer is at this distance, the portal becomes solid and closes off."
	TranslucencyLimit(string) : "Translucency limit" : "0.2" : "This value limits the translucency of the bmodel and prevents it from becoming invisible when the viewer is right on top of it."
	BackgroundBModel(string) : "Foreground bmodel" : "" : "(Optional) brush model that is drawn after the fading brush model. This model should have alpha in its textures so you can see through it."
	PortalVersion(integer) readonly : "Portal Version" : 1 : "(Don't change). Differentiates between shipping HL2 maps and maps using new engine features."
]

@SolidClass base(Targetname, Parentname, RenderFields, Global, Inputfilter, EnableDisable, Shadow) = func_brush : 
	"A brush built entity with various features." 
[
	spawnflags(flags) =
	[
		2: "Ignore player +USE" : 1
	]

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	Solidity(choices) : "Solidity" : 0 : "Used to control the solidity/collision of these brushes." =
	[
		0 : "Toggle"
		1 : "Never Solid"
		2 : "Always Solid"
	]
	excludednpc(string) : "NPC class excluded from collisions" : "" : "If an NPC classname is specified here, NPCs of that type won't collide with these brushes. In Episodic, you may also specify an individual entity's name."
	invert_exclusion(choices) : "Invert NPC class exclusion" : 0 : "If set, then the excluded NPC class will consider this brush solid, and all other NPC classes will consider it non-solid." =
	[
		0 : "No"
		1 : "Yes"
	]	

	solidbsp(choices) : "Solid BSP" : 0 : "Set this if this brush is in heirarchy with a moving object of some kind, and the player can stand on this brush." =
	[
		0 : "No"
		1 : "Yes"
	]	
	vrad_brush_cast_shadows(choices) : "Shadows" : 0 : "Set this if this brush casts lightmap shadows." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@SolidClass base(Targetname, Parentname, RenderFields, DamageFilter) = func_button : 
	"A brush entity that's designed to be used for a player-useable button. When used by the player, it moves to a pressed position."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "Specifies the direction of motion to move when the button is used."
	speed(integer) : "Speed" : 5 : "The speed that the button moves, in inches per second."
	health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	lip(integer) : "Lip" : 0 : "The amount, in inches, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be pressed."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None (Silent)"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		11: "Buzz Off"
		12: "latch locked"
		13: "Latch Unlocked"
		14: "Lightswitch"
		15: "small bleek"
		16: "small deny"
		17: "small doop"
		18: "small tech deny"
		19: "click and combine screen fuzz"
		20: "roomy beep"
		21: "lever or wheel: turn + move sqeek"
		22: "lever or wheel: latch + release gas"
		23: "lever or wheel: ratchet + sqeek"
		24: "lever or wheel: large ratchet"
		25: "lever or wheel: clanky + gas release"
		26: "lever or wheel: latch + large metal thud"
		27: "lever or wheel: smaller ratchet"
		28: "lever or wheel: smaller lever move"
		31: "shock buzz"
		32: "clickbeep"
		33: "tech blip"
		34: "clickbeepbeep open"
		35: "small high blip"
		36: "small tech fuzz blip"
		37: "small click bleep (change to lightswitch)"
		40: "combine door lock - locked"
		41: "combine blip growl"
		42: "combine squick growl"
		43: "combine whine purr"
		44: "combine click talk"
		45: "combine click growl fizz"
		46: "combine click fizz (deny)"
		47: "combine click talker"
	]	
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	spawnflags(flags) =
	[
		1: "Don't move" : 0
		32: "Toggle" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		4096: "Sparks" : 0
	]
	locked_sound(choices) : "Locked Sound" : 0 : "Sound played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		2: "Access Denied"
		8: "Small zap"
		10: "Buzz"
		11: "Buzz Off"
		12: "Latch Locked"
	]
	unlocked_sound(choices) : "Unlocked Sound" : 0 : "Sound played when the button is unlocked." = 
	[
		0: "None"
		1: "Big zap & Warmup"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		10: "Buzz"
		13: "Latch Unlocked"
		14: "Lightswitch"
	]
	locked_sentence(choices) : "Locked Sentence" : 0 : "A sentence played when the player tries to use the button, and fails because it's locked." = 
	[
		0: "None"
		1: "Gen. Access Denied"
		2: "Security Lockout"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance Door"
		9: "Broken Shut Door"
	]
	unlocked_sentence(choices) : "Unlocked Sentence" : 0 : "A sentence played when the button is unlocked." = 
	[
		0: "None"
		1: "Gen. Access Granted"
		2: "Security Disengaged"
		3: "Blast Door"
		4: "Fire Door"
		5: "Chemical Door"
		6: "Radiation Door"
		7: "Gen. Containment"
		8: "Maintenance area"
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, EnableDisable) = func_clip_vphysics : 
	"A brush entity that's considered solid to vphysics." 
[
	filtername(PointClass) : "Filter Name" : : "Filter to use to see if activator collides with me. See filter_activator_name for more explanation. Allow means 'Allow to Block' for this entity."
]

@SolidClass base(Door) = func_door : 
	"A brush entity for use as a player-useable door."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the door will move, when it opens."

	filtername(PointClass) : "Block Filter Name" : : "Filter to use to determine entities that block the door. ( Half-Life: Source port only )"
]

@SolidClass base(Door, Angles) = func_door_rotating : 
	"A brush entity for use as a rotating player-useable door." 
[
	spawnflags(flags) =
	[
		2 : "Reverse Dir" : 0
		16: "One-way" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		65536: "New func_door +USE rules (NOT for prop_doors!!)" : 0
	]
	distance(integer) : "Distance" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."

	solidbsp(choices) : "Solid Type" : 1 =
	[
		0 : "VPhysics"
		1 : "BSP"
	]
]

@SolidClass = func_detail []

@SolidClass = func_group : "Group of brushes (no effect in game)" []

@SolidClass = func_illusionary : "Static nonsolid model" []

@SolidClass base(Targetname) = func_lod : 
	"Brush-built model that fades out over a specified distance. Useful for creating world detail that doesn't need to be drawn far away, for performance reasons."
[
	DisappearDist(integer)	: "Disappear Distance" : 2000 : "Distance at which these brushes should fade out."
	Solid(choices) : "Solid" : 0 : "Set whether or not these brushes should collide with other entities." =
	[
		0: "Solid"
		1: "Nonsolid"
	]
]

@SolidClass base(Targetname, Parentname, Angles, Global, EnableDisable) = func_rot_button : 
	"A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position."
[
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	speed(integer) : "Speed" : 50 : "The speed that the button rotates, in degrees per second."
	health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	sounds(choices) : "Sounds" : 21 = 
	[
		0: "None (Silent)"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	distance(integer) : "Distance (deg)" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."
	// TODO: move spawnflags into Button base class?
	spawnflags(flags) =
	[
		1 : "Not solid" : 0
		2 : "Reverse Dir" : 0
		32: "Toggle" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates": 0
		2048: "Starts locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname, Angles, RenderFields) = momentary_rot_button : 
	"A brush entity that's designed to be used for rotating wheels, where the player can rotate them to arbitrary positions before stopping."
[
	speed(integer) : "Speed (deg/sec)" : 50 : "The amount, in degrees, that the wheel turns per second."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	distance(integer) : "Distance" : 90 : "The maximum amount, in degrees, that the wheel is allowed to rotate."
	returnspeed(integer) : "Auto-return speed" : 0 : "If the 'Toggle' spawnflag is not set, the speed at which the wheel auto-returns when left alone, in degrees per second."
	spawnflags(flags) =
	[
		1: "Not Solid" : 1
		32: "Toggle (Disable Auto Return)" : 1
		64: "X Axis" : 0
		128: "Y Axis" : 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		8192: "Jiggle when used while locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	startposition(float) : "Start Position" : "0" : "Postion when spawned. The value is a range between 0.0 and 1.0, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	startdirection(choices) : "Start Direction" : "Forward" =
	[
		-1 : "Forward"		 // Reverses upon USE, so are
		1 : "Backward"	 // reversed here.
	]
	solidbsp(choices) : "Solid Type" : 1 =
	[
		0 : "VPhysics"
		1 : "BSP"
	]
]





//////////////////////////////////////////////////////
//
// logic entities
//
//////////////////////////////////////////////////////

@PointClass = logic_auto : 
	"Fires outputs when a map spawns. " +
	"If 'Remove on fire' flag is set the logic_auto is deleted after firing. " +
	"It can be set to check a global state before firing. This allows you to only fire events based on "+
	"what took place in a previous map."
[
	spawnflags(Flags) =
	[
		1 : "Remove on fire" : 1
	]
	
	globalstate(choices) : "Global State to Read" : : "If set, this specifies a global state to check before firing. The OnMapSpawn output will only fire if the global state is set." =
	[
		"" : "--- None ---"
		"gordon_precriminal" : "Gordon pre-criminal" 
		"antlion_allied" : "Antlions are player allies" 
		"suit_no_sprint" : "Suit sprint function not yet enabled" 
		"super_phys_gun" : "Super phys gun is enabled" 
		"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
		"gordon_invulnerable" : "Gordon is invulnerable"
		"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
		"is_console" : "Game is running on a console"
		"is_pc" : "Game is running on a PC"
	]
]

@PointClass base(Targetname,Angles,Parentname) = point_viewcontrol : 
	"A camera entity that controls the player's view. While it's active, the player will see out of the camera." 
[
	target(target_destination) : "Entity to Look At" : : "Name of the entity that the camera should point at and track while active."
	targetattachment(string) : "Target Attachment Name" : : "If set, the camera will focus on the specified attachment on the 'Entity to Look At'."
	wait(integer) : "Hold Time" : 10 : "The amount of time the camera should control the player's view for, after which it deactivates itself. If the camera should stay active until told to deactive, set the 'Infinite Hold Time' spawnflag."
	moveto(target_destination) : "Path Corner" : : "The first path corner in a track that the camera should move along once it's activated. If not specified, the camera won't move."
	interpolatepositiontoplayer(choices) : "Interpolate Position To Player" : 0 : "Gradually interpolate player's position to here on start. (Episodic only)" =
	[
		0 : "No"
		1 : "Yes"
	]
	spawnflags(flags) =
	[
		1: "Start At Player" : 1
		2: "Follow Player" : 1
		4: "Freeze Player" : 0
		8: "Infinite Hold Time" : 0
		16:"Snap to goal angles" : 0
		32:"Make Player non-solid" : 0
		64:"Interruptable by Player" : 0
		128:"Set Player FOV" : 0
	]
	speed(string) : "Initial Speed" : "0" : "The starting speed that the camera moves at, if it's on a path track."
	acceleration(string) : "Acceleration units/sec^2" : "500" : "The speed at which the camera accelerates to path corner's desired speeds."
	deceleration(string) : "Stop Deceleration units/sec^2" : "500" : "The speed at which the camera decelerates to path corner's desired speeds."

	fov(integer) : "Player FOV" : 90 : "The FOV to set for the player if the Set Player FOV spawnflag is enabled."
	fov_rate(float) : "FOV Change Rate" : "1" : "The rate at which the player's FOV is set."
]

@PointClass base(Targetname) = point_posecontroller : 
	"An entity that controls a pose parameter of a prop and cycles the pose clientside." 
[
	PropName(string) : "Prop Name" : : "Name of the prop to control."
	PoseParameterName(string) : "Pose Parameter Name" : : "Name of the pose parameter to control."
	PoseValue(float) : "Pose Parameter Value" : "0.0" : "Normalized value for the pose parameter from 0.0 and 1.0 (maps to min and max range)."
	InterpolationTime(float) : "Interpolation Time" : "0.0" : "Number of seconds (0.0 to 10.0) for client to match absolue pose values."
	InterpolationWrap(choices) : "Should wrap from 0.0 to 1.0 when interpolating." : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	CycleFrequency(float) : "Cycle Frequency" : "0.0" : "Base cycles per second from -10.0 to 10.0."
	FModulationType(choices) : "Frequency Modulation Type" : 0 = 
	[
		0: "None"
		1: "Sine"
		2: "Square"
		3: "Triangle"
		4: "Sawtooth"
		5: "Noise"
	]
	FModTimeOffset(float) : "Frequency Modulation Time Offset" : "0.0" : "Modulation time offset from -1.0f to 1.0."
	FModRate(float) : "Frequency Modulation Rate" : "0.0" : "Modulation cycles per second from -10.0f to 10.0."
	FModAmplitude(float) : "Frequency Modulation Amplitude" : "0.0" : "Modulation extents from 0.0f to 10.0."
]

@PointClass base(Targetname) = logic_compare :
	"Compares an input value to another value. " +
	"If the input value is less than the compare value, the OnLessThan output is fired with the input value. " +
	"If the input value is equal to the compare value, the OnEqualTo output is fired with the input value. " +	
	"If the input value is greater than the compare value, the OnGreaterThan output is fired with the input value."
[
	// Keys
	InitialValue(string) : "Initial value" : : "Initial value for the input value."
	CompareValue(string) : "Compare value" : : "The value to compare against."
	StrLenAllowed(choices) : "String length allowed" : 0 : "Whether the input value (if it's numerical) can be compared against the Compare value's string length (if it is one)" =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = logic_branch :
	"Tests a boolean value and fires an output based on whether the value is true or false. " +
	"Use this entity to branch between two potential sets of events."
[
	// Keys
	InitialValue(integer) : "Initial value" : : "Initial value for the boolean value (0 or 1)."
]


@PointClass base(Targetname) = logic_branch_listener :
	"Contains a list of logic_branch entities and fires outputs when the state of any of the logic_branches changes.\n\n"+
	"This entity is used to fire an event when a set of conditions are all satisfied."
[
	Branch01(target_destination) : "Logic Branch 01" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch02(target_destination) : "Logic Branch 02" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch03(target_destination) : "Logic Branch 03" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch04(target_destination) : "Logic Branch 04" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch05(target_destination) : "Logic Branch 05" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch06(target_destination) : "Logic Branch 06" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch07(target_destination) : "Logic Branch 07" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch08(target_destination) : "Logic Branch 08" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch09(target_destination) : "Logic Branch 09" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch10(target_destination) : "Logic Branch 10" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch11(target_destination) : "Logic Branch 11" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch12(target_destination) : "Logic Branch 12" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch13(target_destination) : "Logic Branch 13" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch14(target_destination) : "Logic Branch 14" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch15(target_destination) : "Logic Branch 15" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch16(target_destination) : "Logic Branch 16" : : "The name of one or more logic_branches (wildcards allowed)."
]


@PointClass base(Targetname) = logic_case :
	"Compares an input to up to 16 preset values. If the input value is the same as " +
	"any of the preset values, an output corresponding to that value is fired.\n\n" +
	"For example: if Case01 is set to 2 and Case02 is set to 5, and the input value is 5, " +
	"the OnCase02 output will be fired.\n\n" +
	"This entity can also be used to select from a number of random targets via the " +
	"PickRandom input. One of the OnCase outputs that is connected to another entity will " +
	"be picked at random and fired."
[
	MultipleCasesAllowed(choices) : "Multiple case hits allowed" : 0 : "If an input value matches a given case, are we allowed to test the rest of the cases or should we stop there? Don't worry about this if you're only using this entity for PickRandom." =
	[
		0 : "No"
		1 : "Yes"
	]

	Case01(string) : "Case 01"
	Case02(string) : "Case 02"
	Case03(string) : "Case 03"
	Case04(string) : "Case 04"
	Case05(string) : "Case 05"
	Case06(string) : "Case 06"
	Case07(string) : "Case 07"
	Case08(string) : "Case 08"
	Case09(string) : "Case 09"
	Case10(string) : "Case 10"
	Case11(string) : "Case 11"
	Case12(string) : "Case 12"
	Case13(string) : "Case 13"
	Case14(string) : "Case 14"
	Case15(string) : "Case 15"
	Case16(string) : "Case 16"
]


@PointClass base(Targetname, EnableDisable)= logic_random_outputs :
	"A message forwarder. Fires up to 16 separate outputs, each with a different chance of firing."
[
	spawnflags(flags) =
	[
		1: "Only trigger once" : 0
		2: "Allow fast retrigger" : 0
	]
	OnTriggerChance1(float) : "OnTrigger1 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger1 output firing when this entity is triggered."
	OnTriggerChance2(float) : "OnTrigger2 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger2 output firing when this entity is triggered."
	OnTriggerChance3(float) : "OnTrigger3 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger3 output firing when this entity is triggered."
	OnTriggerChance4(float) : "OnTrigger4 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger4 output firing when this entity is triggered."
	OnTriggerChance5(float) : "OnTrigger5 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger5 output firing when this entity is triggered."
	OnTriggerChance6(float) : "OnTrigger6 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger6 output firing when this entity is triggered."
	OnTriggerChance7(float) : "OnTrigger7 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger7 output firing when this entity is triggered."
	OnTriggerChance8(float) : "OnTrigger8 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger8 output firing when this entity is triggered."
	OnTriggerChance9(float) : "OnTrigger9 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger9 output firing when this entity is triggered."
	OnTriggerChance10(float) : "OnTrigger10 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger10 output firing when this entity is triggered."
	OnTriggerChance11(float) : "OnTrigger11 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger11 output firing when this entity is triggered."
	OnTriggerChance12(float) : "OnTrigger12 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger12 output firing when this entity is triggered."
	OnTriggerChance13(float) : "OnTrigger13 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger13 output firing when this entity is triggered."
	OnTriggerChance14(float) : "OnTrigger14 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger14 output firing when this entity is triggered."
	OnTriggerChance15(float) : "OnTrigger15 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger15 output firing when this entity is triggered."
	OnTriggerChance16(float) : "OnTrigger16 Chance" : "1.0" : "Chance (from 0 to 1) of the OnTrigger16 output firing when this entity is triggered."
]


// Original Comment >>> NEEDHELP: Unused in HL2, not clear what it's useful for.
// 
// Apparently, this entity's usefulness was called into question at some point by Valve programmers.
// Either way, I've changed it a lot, so this may (or may not) be useful now.
@PointClass base(Targetname) = logic_multicompare :
	"Compares a set of inputs to each other. If they are all the same, fires an OnEqual output. " +
	"If any are different, fires the OnNotEqual output." +
	"There is currently no way to remove inputs."
[
	// Keys
	IntegerValue(string) : "Reference Value (optional)" : : "The value all inputs are compared to if ''Should use Reference Value'' is enabled."
	ShouldComparetoValue(choices) : "Should use Reference Value" : 0 : "If enabled, all inputs are compared to the reference value. If not enabled, they are instead compared to the last input added." =
	[
		0 : "No"
		1 : "Yes"
	]
	StrLenAllowed(choices) : "String length allowed" : 0 : "Whether the input value (if it's numerical) can be compared against the Compare value's string length (if it is one)" =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname, EnableDisable) = logic_relay :
	"A message forwarder. Fires an OnTrigger output when triggered, and " +
	"can be disabled to prevent forwarding outputs. " +
	"Useful as an intermediary between one entity and another for turning " +
	"on or off an I/O connection, or as a container for holding a set of " +
	"outputs that can be triggered from multiple places."
[
	spawnflags(flags) =
	[
		1: "Only trigger once" : 0
		2: "Allow fast retrigger" : 0
	]
]

@PointClass base(Targetname, EnableDisable) = logic_relay_queue :
	"A special variant of logic_relay designed to queue trigger inputs. " +
	"If the relay is still handling its I/O connections after being triggered, additional Trigger inputs will be queued and automatically fire when the relay is able to be re-fired. Activator, output ID, and parameter are all kept and saved. " +
	"Inputs are added to the queue each time Trigger or TriggerWithParameter are received while the relay is disabled or still handling its current I/O connections. The first one in the queue will trigger the moment an opportunity becomes available and the next one in the queue will wait for that one. " +
	"This is useful for when you don't want something to happen multiple times at once, but don't want to discard further requests either."
[
	SetMaxQueueItems(integer) : "Maximum Items" : 3 : "The maximum number of Trigger and TriggerWithParameter inputs allowed in the queue. Any others received while this value is full will be discarded. Keep in mind this does not count the I/O chain currently being handled."
	
	DontQueueWhenDisabled(choices) : "Don't queue when disabled" : 0 : "Prevents the relay from queuing inputs when disabled. This means inputs will only be queued when enabled and still handling its current I/O connections." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname, EnableDisable) = logic_timer :
	"An entity that fires a timer event at regular, or random, intervals. It can also be set to oscillate between" + 
	"a high and low end, in which case it will fire alternating high/low outputs each time it fires."
[
	// Keys
	spawnflags(flags) =
	[
		1 : "Oscillator (alternates between OnTimerHigh and OnTimerLow outputs)" : 0
	]

	UseRandomTime(choices) : "Use Random Time" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	LowerRandomBound(string) : "Minimum Random Interval" : : "If 'Use Random Time' is set, this is the minimum time between timer fires. The time will be a random number between this and the 'Maximum Random Interval'."
	UpperRandomBound(string) : "Maximum Random Interval" : : "If 'Use Random Time' is set, this is the maximum time between timer fires. The time will be a random number between the 'Minimum Random Interval' and this."
	RefireTime(string) : "Refire Interval" : : "If 'Use Random Time' isn't set, this is the time between timer fires, in seconds."
	
	UseBoundsForTimerInputs(choices) : "Limit Timer Inputs" : 0 : "Allows the Minumum/Maximum Random Interval keyvalues to limit the total timer value when it receives AddToTimer or SubtractFromTimer inputs." =
	[
		0 : "No"
		1 : "Yes"
	]
]


@PointClass base(Targetname) = hammer_updateignorelist :
	"Specifies entities that are to be ignored by the hammer_update_safe_entities console command. " + 
	"Enter the targetnames of entities that you want to exclude into the list of fields here. " +
	"Several of these may exist in a map."
[
	IgnoredName01(target_destination) : "IgnoredName 01" : "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName02(target_destination) : "IgnoredName 02" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName03(target_destination) : "IgnoredName 03" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName04(target_destination) : "IgnoredName 04" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName05(target_destination) : "IgnoredName 05" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName06(target_destination) : "IgnoredName 06" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName07(target_destination) : "IgnoredName 07" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName08(target_destination) : "IgnoredName 08" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName09(target_destination) : "IgnoredName 09" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName10(target_destination) : "IgnoredName 10" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName11(target_destination) : "IgnoredName 11" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName12(target_destination) : "IgnoredName 12" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName13(target_destination) : "IgnoredName 13" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName14(target_destination) : "IgnoredName 14" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName15(target_destination) : "IgnoredName 15" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName16(target_destination) : "IgnoredName 16" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
]


@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 255 0) = logic_collision_pair : 
	"An entity that can be used to enables/disable vphysics collisions between two target entities."
[
	attach1(target_destination) : "Attachment 1" : "" : "The first entity."
	attach2(target_destination) : "Attachment 2" : "" : "The second entity."

	startdisabled(choices) : "Start with collisions disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]
]


@PointClass base(Targetname, Parentname, EnableDisable) color(0 0 255) = env_microphone :
	"An entity that acts as a microphone. It works in one of two modes. If it has a 'Speaker' set, it picks up all sounds within the specified sound range, " +
	"and rebroadcasts them through the Speaker entity. In this Speaker mode, it ignores the Hears X spawnflags and does not fire the SoundLevel output. " +
	"If it has no Speaker set, it measures the sound level at a point, and outputs the sound level as a value between 0 and 1. In Measuring mode, it only hears sounds that match the Hear X spawnflags."
[
	target(target_destination) : "Measure target" : : "If the speaker is in Measuring mode, this is the name of the entity where the sound level is to be measured."
	SpeakerName(target_destination) : "Speaker target" : "" : "The name of an info_target entity through which to play any sounds heard by this microphone. If specified, the microphone will consider itself in Speaker mode."
	ListenFilter(PointClass) : "Listen Filter" : "" : "The name of an filter entity which specifies the only entities the microphone can hear. Sounds emitted by other entities will not be heard."
	speaker_dsp_preset(choices) : "Speaker DSP Preset" : 0 : "Only useful in Speaker mode. If specified, when the microphone is enabled, it'll set the global dsp_speaker preset to this value. Sounds played back through speakers will then be affected by the selected DSP." =
	[
		 0 : "Use Default"
		50 : "1 NO EFFECT"
		51 : "2 (DUPLICATE OF 1)"
		52 : "3 (DUPLICATE OF 1)"
		53 : "4 (DUPLICATE OF 1)"
		54 : "5 (DUPLICATE OF 1)"
		55 : "6 SPEAKER, LOUDER"
		56 : "7 SPEAKER VERY SMALL"
		57 : "8 LOUDSPEAKER, ECHO"
		58 : "9 SPEAKER SMALL"
		59 : "10 SPEAKER TINY"
	]

	spawnflags(flags) =
	[
		1 : "Hears combat sounds" : 1
		2 : "Hears world sounds" : 1
		4 : "Hears player sounds" : 1
		8 : "Hears bullet impacts" : 1
		16: "Swallows sounds routed through speakers" : 0
		32: "Hears explosions" : 0
		64: "Ignores non-attenuated sounds" : 0
	]

	Sensitivity(float) : "Sensitivity (0 - 10)" : "1" : "Microphone sensitivity, 0=deaf, 1=default, 10=extremely sensitive). Only applicable in Measuring mode."
	SmoothFactor(float) : "Smoothing (0 - 1)" : "0" : "Smoothing factor, 0=no smoothing, 1=maximum smoothing). Only applicable in Measuring mode."
	MaxRange(float) : "Maximum hearing range (0=infinite)" : "240" : "Sounds beyond this range won't be heard, irrelevant of attenuation. "+
		"WARNING: setting this to zero (or a value > 1024) when the microphone is in Speaker mode can be very bad for performance!!"
]

@PointClass base(Targetname, EnableDisable ) = math_remap :
	"An entity that remaps a range of input values to a given range of output values."
[
	spawnflags(flags) = 
	[
		1 : "Ignore out of range input values" : 1
		2 : "Clamp output to output range" : 2
	]

	in1(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	in2(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	out1(integer) : "Output Value When Input Is Min." : : "When the input value is equal to 'Minimum Valid Input Value', this is the output value."
	out2(integer) : "Output Value When Input Is Max." : : "When the input value is equal to 'Maximum Valid Input Value', this is the output value."
]

@PointClass base(Targetname) = math_colorblend :
	"Used to create a blend between two colors for controlling the color of another entity."
[
	spawnflags(flags) = 
	[
		1 : "Ignore out of range input values" : 1
	]

	inmin(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	inmax(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	colormin(color255) : "Output RGB color when input is min." : "0 0 0" : "When the input value is equal to 'Minimum Valid Input Value', this is the output RGB color."
	colormax(color255) : "Output RGB color when input is max." : "255 255 255" : "When the input value is equal to 'Maximum Valid Input Value', this is the output RGB color."
]

@PointClass base(Targetname, EnableDisable) = math_counter :
	"Holds a numeric value and performs arithmetic operations upon it. If either the minimum or maximum " +
	"legal value is nonzero, OutValue will be clamped to the legal range, and the OnHitMin/OnHitMax " +
	"outputs will be fired at the appropriate times. If both min and max are set to zero, no clamping is " +
	"performed and only the OutValue output will be fired."
[
	// Keys
	startvalue(float) : "Initial Value" : "0" : "Starting value for the counter."
	min(float) : "Minimum Legal Value" : "0" : "Minimum legal value for the counter. If min=0 and max=0, no clamping is performed."
	max(float) : "Maximum Legal Value" : "0" : "Maximum legal value for the counter. If min=0 and max=0, no clamping is performed."
]

@PointClass base(Targetname, EnableDisable, math_counter) = math_counter_advanced :
	"A special version of math_counter with the ability to perform advanced calculations. " +
	"Otherwise functions identically to math_counter."
[
	// Keys
	PreserveValue(choices) : "Preserve Value?" : 0 : "If set to 'Yes', calculations will fire OutValue with the resulting value, but the actual value stored in this entity will stay the same, allowing future calculations to use a constant value. If you want to change the value, you must use SetValueNoFire to set the counter's value or the PreserveValue input to toggle this feature. This also disables min/max functionality." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	AlwaysOutputAsInt(choices) : "Always Output As Int" : 0 : "If set to 'Yes', the stored value (and OutValue) will always be rounded to an integer before firing." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	SetLerpPercent(float) : "Lerp Percent" : "0.5" : "The percentage used by the LerpTo input."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_lineto : 
	"An entity that calculates and outputs a vector from one entity to another." 
[
	source(target_destination) : "Start entity" : : "Name of the entity the line should start from."
	target(target_destination) : "End entity" : : "Name of the entity that line should end at."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_navigation : 
	"An entity that is used to set navigation properties on other entities. Useful to make NPCs ignore physics props in their way that they can easily push." 
[
	target(target_destination) : "Navigation Entity" : "Name of the entity to set navigation properties on."
	spawnflags(flags) =
	[
		1 : "Start On" : 1
	]
	navprop(choices) : "Nav Property" : "Ignore" =
	[
		"Ignore" : "NPCs Ignore this when navigating (they'll bump into it)"
	]
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_autosave :
	"An entity that is used to force an autosave."
[
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
	
	MinimumHitPoints(integer): "Minimum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
	MinHitPointsToCommit(integer) : "Minimum Hit Points to Commit" : 0 : "Minimum hitpoints required to commit to save. The save will be made if you have at least Minimum Hit Points, but when the autosave timer expires, the autosave is only kept if you have at least Min Hitpoints to Commit."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = logic_active_autosave :
	"An entity that is used to look for opportunities to autosave."
[
	MinimumHitPoints(integer): "Initiation Hit Points" : 30 : "Start looking for an opportunity to save if player drops below this hitpoint level."
	TriggerHitPoints(integer): "Trigger Hit Points" : 75 : "If started looking for an opportunity, save when hitpoints reach this level."
	TimeToTrigget(float): "Time to trigger" : "0" : "If > 0, how long to try and get a save off before giving up"
	DangerousTime(float): "Dangerous time" : "10" : "If 0, just autosave. Otherwise, do an autosavedangerous with this time threshold"
]

@PointClass base(Targetname) = logic_console :
	"Sends messages to the console. Not to be confused with point_clientcommand or point_servercommand."
[
	// Keys
	SetDevLvl(integer) : "Developer Level" : 1 : "What level developer messages should appear at."
	SetMsgColor(color255) : "Message Color" : "210 250 255 255" : "The color of standard messages."
	SetWarningColor(color255) : "Warning Color" : "255 210 210 255" : "The color of warning messages."
	
	SetNewLineNotAuto(choices) : "Don't automatically append \n?" : 0 : "Prevents this logic_console from automatically appending a new line each time it prints." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = logic_convar :
	"A powerful entity that can read the specified ConVar's value. " +
	"It functions similarly to a logic_branch, except you could also output the value directly. " +
	"Due to theoretical abuse, players have the option to disable logic_ConVar usage on a map. " +	
	"Use the 'OnDenied' output to prevent any issues from players who have disabled logic_ConVar."
[
	// Keys
	SetConVar(string) : "ConVar" : : "The ConVar to read. Can be serverside or clientside(?)"
	SetTestValue(string) : "Compare value" : : "The value to compare with the ConVar's value during comparisons. You could use <, !=, etc. at the beginning similar to a Response System criterion."
]

@PointClass base(Targetname) = logic_format :
	"Formats a line of text akin to C# String.Format.\n" +
	"As curly brackets cannot be used in the help window, please see Mapbase documentation for clear instructions."
	//"For example, take the following values:\n\n" +
	//"Input Value: 'A  {0} there and a \{1\} {1} there\n" +
	//"Parameter 0: 'poot'\n" +
	//"Parameter 1: 'doot'\n" +
	//"\n" +
	//"The 'GetFormattedString' input will create the following text:\n\n" +
	//"'A poot poot there and a doot doot there'\n\n" +
	//"This will be sent out via the OutFormattedValue output."
[
	// Keys
	SetInputValue(string) : "Input Value" : : "The input value. Should contain {0}, {1}, etc, which will be replaced by the parameters and then output as OutFormattedValue."
	SetParameter0(string) : "Parameter 0" : : "Will replace all instances of {0} in the input value."
	SetParameter1(string) : "Parameter 1" : : "Will replace all instances of {1} in the input value."
	SetParameter2(string) : "Parameter 2" : : "Will replace all instances of {2} in the input value."
	SetParameter3(string) : "Parameter 3" : : "Will replace all instances of {3} in the input value."
	SetParameter4(string) : "Parameter 4" : : "Will replace all instances of {4} in the input value."
	SetParameter5(string) : "Parameter 5" : : "Will replace all instances of {5} in the input value."
	SetParameter6(string) : "Parameter 6" : : "Will replace all instances of {6} in the input value."
	SetParameter7(string) : "Parameter 7" : : "Will replace all instances of {7} in the input value."
	SetBackupParameter(string) : "Backup Parameter" : : "If an invalid parameter is used (e.g. null parameter or asks for a parameter beyond {7}), then this will be used instead. Otherwise just uses '<null>'."
]

@PointClass base(Targetname) = logic_keyfield :
	"A logic entity that could read an entity's keyfields. " +
	"Use the target and key name options if you want to store a specific target and/or keyvalue. " +
	"Use the 'Test' input to look for the key within the target's datadesc. " +
	"The 'OutValue' output will fire with the keyfield's value if it is found." +
	"\n\nPlease note that some keyvalues do not work with this entity. (most do though, so don't worry about it)"
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity with the key to measure."
	keyname(string) : "Key Name" : : "The name of the key to measure."
]

@PointClass base(Targetname) = logic_datadesc_accessor :
	"A logic entity that could read or write any field in an entity's data description, keyvalue or not, based on its internal name. It otherwise functions identically to logic_keyfield.\n\n" +
	"You'd better know what you're doing."
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity whose data description will be measured."
	keyname(string) : "Element Name" : : "The internal name (e.g. m_iName) of the field to measure. Use the ''ent_info_datatable'' command followed by an entity's class name to see all of their fields."
]

@PointClass base(Targetname) = math_clamp :
	"Clamps a value between two values. Supports integers, floats, and vectors."
[
	// Keys
	SetMax(string) : "Max" : : "The maximum value. Can be an integer, a float, or a vector."
	SetMin(string) : "Min" : : "The minimum value. Can be an integer, a float, or a vector."
]

@PointClass base(Targetname, EnableDisable) = math_bits :
	"A math_counter variant that specializes in bitwise operations."
[
	// Keys
	startvalue(integer) : "Initial Value" : 0 : "The bits this entity should start with."
]

@PointClass base(Targetname, EnableDisable) = math_vector :
	"A math_counter variant that specializes in vector operations."
[
	// Keys
	startvalue(vector) : "Initial Value" : "0 0 0" : "The vector this entity should start with."
	
	spawnflags(flags) =
	[
		1 : "Disable X" : 0
		2 : "Disable Y" : 0
		4 : "Disable Z" : 0
	]
]

@PointClass base(Targetname, EnableDisable) = math_mod :
	"A lightweight entity that performs simple calculations on the fly without needing a complicated I/O chain. "+
	"This is useful for values that are outputted on a per-frame basis and might not work with a math_counter chain."
[
	// Keys
	startvalue(string) : "Mod Value" : "0" : "The value that is applied to input values."
	
	SetOperator(choices) : "Operator" : 43 : "What calculation to perform with the mod value. (input value _ mod value)" = 
	[
		43 : "Addition"
		45 : "Subtraction"
		42 : "Multiplication"
		47 : "Division"
	]
]

@PointClass base(Targetname, EnableDisable) size(-8 -8 -8, 8 8 8) = logic_modelinfo :
	"Gets and outputs some model information from an entity."
[
	target(target_destination) : "Target" : "" : "The entity whose model will be evaluated."
	PoseParameterName(string) : "Pose Parameter Name" : "" : "(Optional) The pose parameter to use for pose parameter-related I/O."
]

@PointClass base(Targetname, EnableDisable) size(-8 -8 -8, 8 8 8) = game_globalvars :
	"Outputs a few global variables when requested." []

@PointClass base(Targetname) = logic_entity_position :
	"Outputs an entity's position. Prediction operations can be performed as well."
[
	target(target_destination) : "Target" : "" : "Who's position should be measured? Use the SetTarget input to change mid-game."
	PositionType(choices) : "Position Type" : 0 : "What position should be measured." =
	[
		0 : "Origin (default)"
		1 : "Local Origin"
		2 : "Worldspace Center"
		3 : "Eyes"
		4 : "Ears"
		5 : "Attachment (use parameter keyvalue)"
	]
	PositionParameter(string) : "Position Type Parameter" : "" : "If using an attachment's position, enter the name of the attachment here."
]

@PointClass base(Targetname) = logic_context_accessor :
	"A logic entity that could read an entity's response contexts. " +
	"Use the target and context name keyvalues if you want to store a specific target and/or context. " +
	"Use the 'Test' input to look for the context on the target. " +
	"The 'OutValue' output will fire with the context's value if it is found."
[
	// Keys
	target(target_destination) : "Target Entity" : : "The entity with the context to measure."
	context(string) : "Context Name" : : "The name of the context to measure."
]

@PointClass base(Targetname, EnableDisable) = math_lightpattern :
	"A logic entity that attempts to replicate light patterns that can be used on named lights.\n\n" +
	"WARNING: This is currently out of sync with default light patterns. TODO: Fix that!"
[
	// Keys
	style(Choices) : "Appearance" : "" : "Which preset pattern to use." =
	[
		"" : "None"
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	
	pattern(string) : "Custom Appearance" : : "A custom pattern to use. a = fully dark, z = fully bright. This should always contain lowercase letters for light patterns. Uppercase letters or other types of characters won't work with actual light patterns. (although they shouldn't break the whole entity either)"
	
	PatternSpeed(float) : "Pattern Speed" : "0.1" : "The speed of the pattern."
]

@PointClass base(Targetname) = logic_sequence :
	"Coordinates a sequence out of up to 16 preset values. If the input value matches " +
	"the sequence's current case value, an output is fired and (by default) the sequence increments to the next case.\n\n" +
	"This is intended for things like passwords in keypads, which usually demand a specific combination of numbers."
[
	InitialCase(integer) : "Initial Case" : 1 : "Which case to start on, meaning inputs will initially compare with this case. Uses the case's index. (e.g. 4 for Case 04)"
	
	StartDisabled(choices) : "Start Disabled" : 0 : "If this entity is disabled, it will not accept any case tests. It will still accept other inputs, like SetSequenceIndex." =
	[
		0 : "No"
		1 : "Yes"
	]

	Case01(string) : "Case 01"
	Case02(string) : "Case 02"
	Case03(string) : "Case 03"
	Case04(string) : "Case 04"
	Case05(string) : "Case 05"
	Case06(string) : "Case 06"
	Case07(string) : "Case 07"
	Case08(string) : "Case 08"
	Case09(string) : "Case 09"
	Case10(string) : "Case 10"
	Case11(string) : "Case 11"
	Case12(string) : "Case 12"
	Case13(string) : "Case 13"
	Case14(string) : "Case 14"
	Case15(string) : "Case 15"
	Case16(string) : "Case 16"
	
	DontIncrementOnPass(choices) : "Suppress auto increment" : 0 : "Prevents automatically incrementing the sequence each time a case passes." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname) = math_generate :
	"Continuously generates numbers using various generation modes based on material proxies."
[
	// Keys
	StartDisabled(choices) : "Start Disabled" : 1 =
	[
		0 : "No"
		1 : "Yes"
	]
	
	GenerateType(choices) : "Generation Type" : 1 =
	[
		0 : "Sine Wave (param 1 = time offset, param 2 = sine period)"
		1 : "Linear Ramp (param 1 = rate)"
		2 : "Uniform Noise"
		3 : "Gaussian Noise (param 1 = mean, param 2 = half width)"
		4 : "Exponential (param 1 = scale, param 2 = offset)"
	]
	
	InitialValue(float) : "Initial Value" : "0" : "Starting value for the math_generate."
	SetHitMin(float) : "Minimum Legal Value" : "0" : "Minimum legal value for generation."
	SetHitMax(float) : "Maximum Legal Value" : "1" : "Maximum legal value for generation."
	
	SetParam1(float) : "Parameter 1" : "0" : "Multi-purpose parameter #1 for the generation algorithms to use for their own needs."
	SetParam2(float) : "Parameter 2" : "0" : "Multi-purpose parameter #2 for the generation algorithms to use for their own needs."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_template : 
	"Turns an entity, or set of entities, into a single template that can be instanced anywhere, and multiple times. "+
	"If there are interdependencies (entity I/O, hierarchy, or other name references) between the entities "+
	"in the template, the entities in the template will have their names changed and the interdependencies will "+
	"be reconnected to the changes names. The name change format is as follows: '<original name>&0000', where the 0000 "+
	"will be replaced with the current global template instance, so wildcard searches for '<original name>*' will still find them.\n"+
	"If you don't want the name fixup to happen, because you're only spawning the template once, or you want inputs to "+
	"trigger all instances of the template, check the 'Preserve entity names' spawnflag. \n"+
	"To spawn the template in other places, use an env_entity_maker."
[
	spawnflags(flags) =
	[
		1 : "Don't remove template entities" : 0
		2 : "Preserve entity names (Don't do name fixup)" : 1
	]

	Template01(target_destination) : "Template 1"
	Template02(target_destination) : "Template 2"
	Template03(target_destination) : "Template 3"
	Template04(target_destination) : "Template 4"
	Template05(target_destination) : "Template 5"
	Template06(target_destination) : "Template 6"
	Template07(target_destination) : "Template 7"
	Template08(target_destination) : "Template 8"
	Template09(target_destination) : "Template 9"
	Template10(target_destination) : "Template 10"
	Template11(target_destination) : "Template 11"
	Template12(target_destination) : "Template 12"
	Template13(target_destination) : "Template 13"
	Template14(target_destination) : "Template 14"
	Template15(target_destination) : "Template 15"
	Template16(target_destination) : "Template 16"
]

@PointClass base(Targetname,Parentname,Angles) = env_entity_maker : 
	"Spawns the specified entity template at its origin. If set to auto-spawn, it will spawn the template whenever there's room and the player "+
	"is looking elsewhere." 
[
	spawnflags(Flags) =
	[
		1 : "Enable AutoSpawn (will spawn whenever there's room)" : 0
		2 : "AutoSpawn: Wait for entity destruction" : 0
		4 : "AutoSpawn: Even if the player is looking" : 0
		8 : "ForceSpawn: Only if there's room" : 0
		  16 : "ForceSpawn: Only if the player isn't looking" : 0
	]

	EntityTemplate(target_destination) : "Point_template To Spawn" : "" : "Name of the point_template to spawn here."

	PostSpawnSpeed(float) : "PostSpawn Movement Speed" : "0" : "If specified, all the entities created in the template will move this fast in the specified PostSpawn Movement Direction."
	PostSpawnDirection(angle) : "PostSpawn Movement Direction" : "0 0 0" : "If a PostSpawn Movement Speed is specified, all the entities created in the template will move in this direction."
	PostSpawnDirectionVariance(float) : "PostSpawn Direction Variance" : "0.15" : "This variance is applied to the PostSpawn Movement Direction for each spawned entity in the template. Use it to apply some randomness to the directions."
	PostSpawnInheritAngles(choices) : "PostSpawn Inherit Angles" : 0 : "If in hierarchy, is spawn direction in world space, or object local space of parent" =
	[
		0 : "No"
		1 : "Yes"
	]
]






//////////////////////////////////////////////////////
//
// activator filters
//
//////////////////////////////////////////////////////

@BaseClass base(Targetname) = BaseFilter
[
	Negated(choices) : "Filter mode" : "Allow entities that match criteria" : "If set to Allow, only entities who match the criteria will pass the filter. "+
		"If set to Disallow, only entities who do NOT match the criteria will pass the filter." =
	[
		0 : "Allow entities that match criteria"
		1 : "Disallow entities that match criteria"
	]
	
	PassCallerWhenTested(choices) : "Pass caller when tested" : 0 : "When tested with TestActivator or TestEntity, this causes the OnPass and OnFail outputs to use either this filter as the caller or the entity that called the test as the caller." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(BaseFilter) = filter_multi :
	"A filter that tests the activator against multiple filters. This allows you to build more complex filters, such as"+
	"'Allow anyone on Team 1 who is also class engineer', or 'Allow everyone except classes npc_zombie and npc_headcrab'."
[
	filtertype(choices) : "Logic Type" : 0 =
	[
		0 : "AND (all filters must pass)"
		1 : "OR (any filter must pass)"
	]

	Negated(choices) : "Negate Outcome" : 0 : "Whether to negate the result of the subfilters, after combining them using the Logic Type chosen.\n"+
		"Negating the outcome using the AND logic type means that any subfilter must fail for this filter to pass.\n"+
		"Negating the outcome using the OR logic type means that all subfilters must fail for this filter to pass." =
	[
		0 : "No"
		1 : "Yes"
	]

	Filter01(PointClass) : "Filter 1" : : "Activator filter to test."
	Filter02(PointClass) : "Filter 2" : : "Activator filter to test."
	Filter03(PointClass) : "Filter 3" : : "Activator filter to test."
	Filter04(PointClass) : "Filter 4" : : "Activator filter to test."
	Filter05(PointClass) : "Filter 5" : : "Activator filter to test."
]

@PointClass base(BaseFilter) = filter_activator_name :
	"A filter that filters by the name of the activator."
[
	filtername(target_destination) : "Filter Name" : : "The name to filter by. If the filter mode is Allow, only entities whose "+
		"name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose name matches the string will pass the filter."
]

@PointClass base(BaseFilter) = filter_activator_model :
	"A filter that filters by the model of the activator."
[
	filtermodel(studio) : "Filter Model" : : "The model to filter by. If the filter mode is Allow, only entities whose "+
		"model matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose model matches the given string will pass the filter."
		
	skin(string) : "Skin" : "-1" : "Some models have multiple versions of their textures, called skins. Use this if you want to filter by skins as well. If you want any skin to be allowed, be sure to leave this at -1! It might automatically change when you choose a model."
]

@PointClass base(BaseFilter) = filter_activator_context :
	"A filter that filters by a context and value on the activator."
[
	ResponseContext(string) : "Filter Context" : : "The context(s) to filter by. Syntax is 'key:value,key:value'. "+
		"Values in this field can use wilcards. For example, if this filter contains 'lastname:*', it will pass any entity with the context 'lastname', regardless of its value. "+
		"Wildcards do not apply to context names and you cannot define the same context multiple times, but inputs like AddContext or RemoveContext can be used to add to the filter context."
		
	any(choices) : "Pass if entity has any of these contexts" : 0 : "Should this filter only pass if the entity contains all of these contexts or can it pass if the entity has at least one of them?" =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(BaseFilter) = filter_activator_keyfield :
	"A filter that filters by the activator's keyfields."
[
	keyname(string) : "Key" : : "The key name to filter by. Please note that certain keyvalues, particularly "+
		"targetnames and base values related to clientside rendering (e.g. render mode), cannot be found by this filter."
		
	value(string) : "Value (Optional)" : : "The key value to filter by. If empty, the filter will pass if the entity just has the keyfield."
]

@PointClass base(BaseFilter) = filter_activator_class :
	"A filter that filters by the class name of the activator."
[
	PointClass(string) : "Filter Classname" : : "The class name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
]

@PointClass base(BaseFilter) = filter_activator_mass_greater :
	"A filter that filters by the mass of the activator."
[
	filtermass(float) : "Filter Mass" : : "The mass to filter by. If the filter mode is Allow, only entities whose "+
		"mass is greater than the give float will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose mass is greater than the given float will pass the filter."
]

@PointClass base(BaseFilter) = filter_damage_type :
	"A damage filter that filters by the type of damage inflicted. This can only be used as a damage filter, not as an activator filter."
[
	damagetype(choices) : "Damage type" : 64 : "The damage type to filter by. If the filter mode is Allow, only damage types that "+
		"match will pass the filter. If the filter mode is Disallow, all damage types EXCEPT those who match will pass the filter." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]
]

@PointClass base(BaseFilter)= filter_enemy :
	"A filter that filters a potential enemy entity by a set of criteria."
[
	filtername(string) : "Name/Classname" : : "The classname or entity name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
		
	filter_radius(float) : "Radius" : "0" : "Radius by which to test the proximity of the enemy.  If the filter mode is Allow, only entities whose "+
		"distance is equal to or closer than the radius will pass the filter. If the filter mode is Disallow, "+
		"all entities outside the radius will pass the filter."

	filter_outer_radius(float) : "Outer Radius" : "0" : "Enemies outside this radius are considered invalid if Allow is set and valid if Disallow is set."
	
	filter_max_per_enemy(integer) : "Max Squadmates Per Enemy" : 0 : "Maximum number of squadmates allowed to target any given entity."
	
	spawnflags(Flags) =
	[
		1 : "Do not lose target if already aquired but filter failed." : 0
	]
]

@PointClass base(BaseFilter)= filter_activator_involume :
	"A filter that tests whether the activator is within a volume."
[
	target(target_destination) : "Volume" : : "The volume to be tested with. This filter passes if the activator is within this volume. Intended to be a brush entity. (e.g. a trigger)"
	
	tester(target_destination) : "Volume Tester" : "!activator" : "Who should be in the volume for the filter to pass?"
]

@PointClass base(BaseFilter)= filter_activator_surfacedata :
	"A filter that tests the activator's surface data."
[
	filtersurfaceprop(choices) : "Surface" : : "The surface to test with." =
	[
		"metal" : "Metal"
		"metalgrate" : "Metal Grate"
		"metalvent" : "Metal Vent"
	]
	
	SurfaceType(choices) : "Type" : 1 : "What to actually filter by."  =
	[
		0 : "Surface Prop"
		1 : "Game Material"
	]
]





//////////////////////////////////////////////////////
//
// physics entities
//
//////////////////////////////////////////////////////

@SolidClass base(BreakableBrush, Targetname, RenderFields, Shadow) = func_physbox : 
	"A brush entity that's physically simulated."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	spawnflags(flags) =
	[
		4096  : "Start Asleep" : 0
		8192  : "Ignore +USE for Pickup" : 0
		16384 : "Debris - Don't collide with the player or other debris" : 0
		32768 : "Motion Disabled" : 0
		65536 : "Use Preferred Carry Angles" : 0
		131072: "Enable motion on Physcannon grab" : 0
		262144: "Not affected by rotor wash" : 0
		524288: "Generate output on +USE " : 1
		1048576 : "Physgun can ALWAYS pick up. No matter what." : 0
		2097152 : "Physgun is NOT allowed to pick this up." : 0 
		4194304 : "Physgun is NOT allowed to punt this object." : 0
		8388608: "Prevent motion enable on player bump" : 0
	]
	
	Damagetype(choices) : "Impact Damage Type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]
	
	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override Parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : "0" : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	health(integer) : "Strength" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	preferredcarryangles(vector) : "Preferred Player-carry Angles" : "0 0 0" : "If the 'Use Preferred Carry Angles' spawnflag is set, this angle is the angle which the object should orient to when the player picks it up, with the physgun or +USE."
	notsolid(choices) : "Not solid to world" : 0 =
	[
		0: "Solid to World"
		1: "Passes through World"
	]
]

@BaseClass base(Targetname) = TwoObjectPhysics
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 0
		// 2 is defined independently by subclasses, do not reuse
		4: "Start inactive" : 0
		8: "Change mass to keep stable attachment to world" : 0
		16: "Do not connect entities until turned on" : 0
	]
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""
	constraintsystem(target_destination) : "Constraint System Manager" : "" : "The name of a phys_constraintsystem that this constraint should be a part of. All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	breaksound(sound) : "Play Sound on Break" : "" : "A sound played when the constraint is broken."
	teleportfollowdistance(float) : "Follow teleport distance" : "0" : "If one object teleports more than this many units away it will cause the other constrained object to teleport to an appropriate relative position."
]
	
@PointClass base(Targetname) = phys_constraintsystem : 
	"An entity used to manage a group of interacting constraints and keep them stable. " +
	"All constraints on a set of entities should be placed in the same system, or they will fight each other during simulation."
[
	additionaliterations(integer) : "Additional System Iterations" : 0 : "Adding iterations makes the interactions among constraints in a system tighter.  It will not compensate for errors due to collision, but will help in cases where objects of disparate mass are constrained to each other."
]

@PointClass base(Targetname,Angles) = phys_keepupright : "A controller that tries to keep an entity facing a particular direction."
[
	spawnflags(flags) =
	[
		1: "Start inactive" : 0
	]

	attach1(target_destination) : "Target Entity" : "" : "The entity to align to the desired angles."
	angularlimit(float) : "Angular Limit" : "15" : "The maximum angular velocity that this controller can compensate for, in degrees per second."
]

@PointClass base(Targetname, Angles) = physics_cannister : 
	"A physically simulated gas cannister that can have its cap shot off, at which point gas will start escaping and cause the cannister to fly around. If it takes enough damage, it will explode."
[
	model(studio) : "World model" : "models/fire_equipment/w_weldtank.mdl"
	spawnflags(flags) = 
	[
		1 : "Start Asleep" : 0
		2 : "Explodes" : 1
	]

	expdamage(string) : "Explosion Damage" : "200.0" : "The amount of damage done by the explosion created when the cannister blows up."
	expradius(string) : "Explosion Radius" : "250.0" : "The radius of the explosion to create when the cannister blows up."
	health(integer) : "Health" : 25 : "The amount of damage the cannister takes before exploding."

	thrust(string) : "Thrust" : "3000.0" : "When the cap has been blown off, and the escaping gas is thrusting the cannister about, this is the amount of thrust generated."
	fuel(string) : "Fuel Seconds" : "12.0" : "The amount of time that gas leaks from the cannister before being considered empty."
	rendercolor(color255) : "Smoke Color (R G B)" : "255 255 255"
	renderamt(integer) : "Smoke Alpha (0 - 255)" : 128
	gassound(sound) : "Thruster Sound" : "ambient/objects/cannister_loop.wav" : "The sound played when the gas is escaping from the cannister."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = info_constraint_anchor : 
	"An entity used to attach constraints to a local position on an entity. Usually constraints will attach to the center of mass of an object. "+
	"Attach the desired constraint to this entity, and then parent this entity to the entity you want the constraint to apply to."
[
	massScale(float) : "Amount to scale the mass of this body in the constraint solver" : "1"
]

@PointClass size(-4 -4 -4, 4 4 4) = info_mass_center :
	"An entity that overrides the mass center of the target physics prop, or func_physbox, by moving it to the info_mass_center's location."
[
	target(target_destination) : "Target object" : ""  : "The entity whose mass center will be overridden."
]

@PointClass base(Targetname) = phys_spring : 
	"A physically simulated spring. "+
	"'Length' is what's known as the 'natural spring length'. This is how long the spring would "+
	"be if it was at rest (nothing hanging on it or attached). When you attach something to the "+
	"spring, it will stretch longer than its 'natural length'. The amount of stretch is "+
	"determined by the 'Sprint Constant'. The larger the spring constant the less stretch the spring."
[
	spawnflags(flags) =
	[
		1 : "Force only on stretch" : 0
	]

	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""

	springaxis(vecline) : "Spring Axis" : "" : "Use the helper. Drag it out to match the virtual spring."
	length(string) : "Spring Length" : "0" : "How long the spring would be if it was at rest (nothing hanging on it or attached). 0 means the length of the brush."
	constant(string) : "Spring Constant" : "50" : "Stiffness of the spring.  The larger the number the less the spring will stretch."
	damping(string) : "Damping Constant" : "2.0" : "How much energy the spring loses.  The larger the number, the less bouncy the spring."
	relativedamping(string) : "Relative Damping Constant" : "0.1" : "The amount of energy the spring loses proportional to the relative velocity of the two objects the spring is attached to."
	// UNDONE: add max tension and what event to fire when it breaks
	breaklength(string) : "Break on Length" : "0" : "If the spring's length ever exceeds this length, the spring breaks."
]

@PointClass size(-8 -8 -8, 8 8 8) base(TwoObjectPhysics) = phys_hinge : 
	"A physically simulated hinge. Use the helper to define the axis of rotation."
[
	hingefriction(float) : "Friction" : "0" : "Resistance/friction in the hinge"
	hingeaxis(vecline) : "Hinge Axis"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	
	//// Episodic only -- for now.
	
	minSoundThreshold(float) : "Minimum Sound Velocity" : "6" : "When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : "80" : "When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" : "" : "Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" : "" : "Play this sound when travelling backward on helper axis"
	
	reversalsoundthresholdSmall(float) : "Reversal sound threshold (small)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the small reversal sound." 
	reversalsoundthresholdMedium(float) : "Reversal sound threshold (medium)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the medium reversal sound."
	reversalsoundthresholdLarge(float) : "Reversal sound threshold (large)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the large reversal sound."
	
	reversalsoundSmall(sound) : "Reversal sound (small)" : "" : "Play this sound when making a hard reverse over the small threshold but less than medium"
	reversalsoundMedium(sound) : "Reversal sound (medium)" : "" : "Play this sound when making a hard reverse over the medium threshold but less than large"
	reversalsoundLarge(sound) : "Reversal sound (large)" : "" : "Play this sound when making a hard reverse over the large threshold"
]

@PointClass base(TwoObjectPhysics) = phys_ballsocket : 
	"A constraint that keeps the position of two objects fixed, relative to the constraint's origin. It does not affect rotation." []

@PointClass base(TwoObjectPhysics) = phys_constraint : 
	"A constraint that keeps the relative position and orientation of two objects fixed." []

@PointClass base(TwoObjectPhysics) = phys_pulleyconstraint : 
	"A constraint that is essentially two length constraints and two points. Imagine it as a virtual rope connected to two objects, each suspended from a pulley above them."+
	"The constraint keeps the sum of the distances between the pulley points and their suspended objects constant."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the pulley rope."
	gearratio(float) : "Pulley Gear Ratio" : "1" : "Add (or subtract) this amount to the rest length of the pulley rope."
	position2(vecline) : "Pulley Position 2" : : "The position of the pulley for Entity 2. The pulley for Entity 1 is the origin of this constraint entity. Entity 1 is always suspended from pulley point 1, and Entity 2 is always suspended from pulley point 2."
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass base(TwoObjectPhysics) = phys_slideconstraint : 
	"A constraint that constrains an entity along a line segment."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Limit Endpoints" : 0
	]
	slideaxis(vecline) : "Sliding Axis"
	slidefriction(float) : "Friction" : "0" : "Resistance/friction in the constraint"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the mass load connected to this constraint (1=just the objects directly connected)"
	
	//// Episodic only -- for now.
	
	minSoundThreshold(float) : "Minimum Sound Velocity" : "6" : "When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : "80" : "When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" : "" : "Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" : "" : "Play this sound when travelling backward on helper axis"
	
	reversalsoundthresholdSmall(float) : "Reversal sound threshold (small)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the small reversal sound." 
	reversalsoundthresholdMedium(float) : "Reversal sound threshold (medium)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the medium reversal sound."
	reversalsoundthresholdLarge(float) : "Reversal sound threshold (large)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the large reversal sound."
	
	reversalsoundSmall(sound) : "Reversal sound (small)" : "" : "Play this sound when making a hard reverse over the small threshold but less than medium"
	reversalsoundMedium(sound) : "Reversal sound (medium)" : "" : "Play this sound when making a hard reverse over the medium threshold but less than large"
	reversalsoundLarge(sound) : "Reversal sound (large)" : "" : "Play this sound when making a hard reverse over the large threshold"
]

@PointClass base(TwoObjectPhysics) = phys_lengthconstraint : 
	"A constraint that preserves the distance between two entities. If the 'Keep Rigid' flag is set, think of it as a rod. If not, think off it as a virtual rope."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the rope."
	minlength(float) : "Minimum Length" : "0" : "If the constraint is not rigid, this is the minimum length it can be."
	attachpoint(vecline) : "Attached object 2 point" : "The position the rope attaches to object 2"
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass base(TwoObjectPhysics) = phys_ragdollconstraint : 
	"A constraint that fixes the position of two entities, relative to this constraint's origin. Also allows for limits on the rotation around each axis, in the space of this constraint."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Only limit rotation (free movement)" : 0
	]

	xmin(float) : "X axis min limit" : "-90" : "-180 min and 180 max = no constraint on this axis."
	xmax(float) : "X axis max limit" : "90" : "-180 min and 180 max = no constraint on this axis."
	ymin(float) : "Y axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	ymax(float) : "Y axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmin(float) : "Z axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmax(float) : "Z axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	xfriction(float) : "X axis friction" : "0"
	yfriction(float) : "Y axis friction" : "0"
	zfriction(float) : "Z axis friction" : "0"
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) color(0 0 255) = phys_convert : 
	"Turns an arbitrary entity into a physically simulated entity. i.e. brush entities will behave like func_physbox, model entities behave like prop_physics."
[
	spawnflags(flags) =
	[
		1: "Convert Asleep" : 0
		2: "Convert As Debris" : 0
	]
	target(target_destination) : "Entity to convert" : : "Name of the entity that will be converted to a physics object when the ConvertTarget input is fired."
	swapmodel(string) : "Model Swap Entity"
	massoverride(float) : "Mass Override" : "0" : "Sets the mass when the object(s) are converted (0 means auto-calculate)"
]

@BaseClass base(Targetname) = ForceController
[
	spawnflags(flags) =
	[
		// Thrust is on by default (will turn off in forcetime)
		1: "Start On" : 0
		// Apply linear force (if off, torque only)
		2: "Apply Force" : 1
		// Apply rotational force (torque - if off, linear only)
		4: "Apply Torque" : 1
		// Maintain local relationship with the attached object
		8: "Orient Locally" : 1
		// Impulse is independent of object's mass (impulse is acceleration NOT force)
		16: "Ignore Mass" : 0
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to."

	forcetime(string) : "Time of Force (0=inf)" : "0" : "Automatic shut-off after this time has passed (0 = stay on forever or until deactivated)"
]

@PointClass base(Angles, ForceController) = phys_thruster : 
	"An entity used to apply constant acceleration to a physics object. "+
	"The force and torque is calculated using the position and direction of the thruster as an impulse. So moving those off the object's center "+
	"will cause torque as well. Torque can be removed by unchecking the 'apply torque' flag. The position of the thruster can be forced to be "+
	"at the object's center by checking to 'ignore pos' flag."
[
	spawnflags(flags) =
	[
		// Put the thrust at the object center
		32: "Ignore Pos" : 0
	]
	
	force(string) : "Force" : "0" : "Force (will be integrated, units are force kg*in/s^2)"
]

@PointClass base(ForceController) = phys_torque : 
	"An angular thruster. Use it to apply angular force to an entity."
[
	// Angular acceleration (units are degress/s^2)
	force(string) : "Angular Acceleration" : "0"
	axis(vecline) : "Rotation Axis" : ""
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = phys_motor : 
	"An entity that tries to spin a target entity at a particular speed."
[
	speed(string) : "Rotation Speed" : "0" : "Angular speed (units are degress/second)"
	spinup(string) : "Spin up time" : "1" : "spin up time in seconds (also affects the rate at which speed changes happen)"
	inertiafactor(float) : "System Interia Scale" : "1.0" : "Make this larger if the object being driven is constrained to a set of heavier objects."
	axis(vecline) : "Rotation Axis" : ""

	spawnflags(flags) =
	[
		// starts on by default
		1: "Start On" : 1
		// Disable world collisions on hinges
		2: "No world collision" : 0
		// motor also acts as a hinge constraining the object to this axis
		4: "Hinge Object" : 1
		// Maintain local relationship with the attached object (NOT WORKING YET)
//		8: "Orient Locally" : 1
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to"
]

@PointClass base(Targetname, Parentname, Angles) = phys_magnet : 
	"An entity that acts like a magnet, attaching metallic physics objects to itself when they touch it."
[
	spawnflags(flags) =
	[
		1 : "Start Asleep" : 0
		2 : "Motion Disabled" : 0
		4 : "Suck On Touch" : 0
		8 : "Allow Attached Rotation" : 0
		16: "Coast jeep pickup hack" : 0
	]

	forcelimit(float) : "Force Limit to Break (lbs)" : "0" : "The amount of force necessary to break a stuck object off the magnet. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the magnet."
	torquelimit(float) : "Torque Limit to Break (lbs * distance)" : "0" : "The amount of torque necessary to break a stuck object off the magnet. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	maxobjects(integer) : "Maximum Attached Objects" : 0 : "The maximum number of physics objects that can be stuck to the magnet at once. 0 = no limit."
]







//////////////////////////////////////////////////////
//
// props
//
//////////////////////////////////////////////////////

@BaseClass = prop_detail_base
[
	model(studio) : "World model"
]

@BaseClass base(Angles, DXLevelChoice) = prop_static_base
[
	model(studio) : "World Model"
	skin(integer) : "Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin instead of the default."
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics"
	]
	disableshadows(choices) : "Disable Shadows" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in inches. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
	[
		0 : "No"
		1 : "Yes"
	]
	fademindist(float) : "Start Fade Dist/Pixels" : "-1" : "Distance at which the prop starts to fade (<0 = use fademaxdist). If 'Screen Space Fade' is selected, this represents the number of pixels wide covered by the prop when it starts to fade."
	fademaxdist(float) : "End Fade Dist/Pixels" : "0" : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades."
	fadescale(float) : "Fade Scale" : "1" : "If you specify a fade in the worldspawn, or if the engine is running under dx7 [hl2/ep1/portal] or dx8 [ep2/tf], then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified." +
												 " This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades." +
												 " Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from, instead of using this entity's origin."
	disablevertexlighting(choices) : "Disable Vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	disableselfshadowing(choices) : "Disable Self-Shadowing with vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	ignorenormals(choices) : "Ignore surface normal for computing vertex lighting" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	generatelightmaps(choices) : "Generate (and use) lightmaps for this static prop" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
	lightmapresolutionx(integer) : "Lightmap Resolution X" : 32 : "The resolution of the generated lightmap in the X (or U) direction (only used if Generate Lightmaps is Yes) "
	lightmapresolutiony(integer) : "Lightmap Resolution Y" : 32 : "The resolution of the generated lightmap in the Y (or V) direction (only used if Generate Lightmaps is Yes) "
]

@BaseClass = BaseFadeProp
[
	fademindist(float) : "Start Fade Dist" : "-1" : "Distance at which the prop starts to fade (<0 = use fademaxdist)."
	fademaxdist(float) : "End Fade Dist" : "0" : "Max fade distance at which the prop is visible (0 = don't fade out)"
	fadescale(float) : "Fade Scale" : "1" : "If you specify a fade in the worldspawn, or if the engine is running under dx7, then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified." +
					" This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades." +
					" Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
]

@BaseClass base(Parentname, Global, Angles, BreakableProp, DXLevelChoice, BaseFadeProp, RenderFields) = prop_dynamic_base
[
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use Bounding Box"
		6: "Use VPhysics"
	]

	spawnflags(flags) =
	[
		64 : "Use Hitboxes for Renderbox" : 0
		256 : "Start with collision disabled" : 0
	]

	DefaultAnim(string) : "Default Animation" : "" : "The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation."

	RandomAnimation(choices) : "Randomly Animate" : 0 : "If set, this prop will randomly choose and play animations, based upon the times specified in 'Min/Max Random Anim Time'. Inbetween the random animations, it will revert to playing the 'Default Animation'." =
	[
		0: "No"
		1: "Yes"
	]
	MinAnimTime(float) : "Min Random Anim Time" : "5" : "Minimum time between random animations."
	MaxAnimTime(float) : "Max Random Anim Time" : "10" : "Maximum time between random animations."
	SetBodyGroup(integer) : "Body Group" : 0	// NEEDHELP
	
	DisableBoneFollowers(choices) : "Disable Bone Followers" : 0 : "If set, this prop won't generate bone followers, even if they're listed in the model's .qc" =
	[
		0: "No"
		1: "Yes"
	]

	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select a path_corner entity to specify a location to sample lighting from, instead of using this entity's origin."
]

@PointClass base(prop_detail_base) = prop_detail : 
	"Detail Prop"
[
	model(studio) : "World model"
]

@PointClass base(prop_static_base) color(255 255 0) = prop_static :
	"A prop that doesn't move and doesn't animate." []

@PointClass base(prop_dynamic_base,EnableDisable) = prop_dynamic :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_physics (i.e. it should be physically simulated) then it CANNOT be "+
	"used as a prop_dynamic. Upon level load it will display a warning in the console and remove itself. Use a prop_physics instead." []

@PointClass base(prop_dynamic_base) = prop_dynamic_override :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage.\n"+
	"prop_dynamic_override is a prototyping entity only. It will allow the use of models designed to be used as prop_physics."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."	
]

@BaseClass base(Targetname, Global, Angles, BreakableProp, DXLevelChoice, BaseFadeProp) = BasePropPhysics
[ 
	spawnflags(flags) = 
	[
		1 : "Start Asleep" : 0
		2 : "Don't take physics damage" : 0
		4 : "Debris - Don't collide with the player or other debris" : 0
		8 : "Motion Disabled" : 0
		64 : "Enable motion on Physcannon grab" : 0
		128 : "Not affected by rotor wash" : 0
		256 : "Generate output on +USE " : 1
		512 : "Prevent pickup" : 0
		1024: "Prevent motion enable on player bump" : 0
		4096: "Debris with trigger interaction" : 0
		8192: "Force server-side (Multiplayer only)" : 0
		1048576: "Physgun can ALWAYS pick up. No matter what." : 0
	]
	
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."
	shadowcastdist(integer) : "Shadow Cast Distance" : 0 : "Use this to override how far this object casts shadows. 0 = default distance."
	physdamagescale(float) : "Physics Impact Damage Scale" : "0.1" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.\nSet to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
	Damagetype(choices) : "Impact damage type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]

	nodamageforces(choices) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	inertiaScale(float) : "Scale Factor For Inertia" : "1.0" : "Scales the angular mass of an object. Used to hack angular damage and collision response."
	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	overridescript(string) : "Override Parameters" : "" : "A list of physics key/value pairs that are usually in a physics prop .qc file. Format is 'key,value,key,value,etc'."
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : "0" : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	
	puntsound(sound) : "Sound to make when punted"
]

@PointClass base(BasePropPhysics) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Health can be overridden on this version."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
]

@PointClass base(BasePropPhysics, RenderFields) = prop_physics :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
	"used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[
]

@PointClass base(prop_physics) = prop_physics_multiplayer :
	"This class is the same as prop_physics, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[
	physicsmode(choices) : "Physics Mode" : 0 =
	[
		0: "Auto Detect"
		1: "Solid, Server-side"
		2: "Non-Solid, Server-side"
		3: "Non-Solid, Client-side"
	]
]

@PointClass base(Angles, Targetname, DXLevelChoice, BaseFadeProp, EnableDisable) = prop_ragdoll :
	"A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model."
[
	spawnflags(flags) = 
	[
		4 : "Debris - Don't collide with the player or other debris" : 1
		8192 : "Allow Dissolve" : 0
		16384 : "Motion Disabled" : 0
		32768 : "Allow stretch" : 0
		65536 : "Start asleep" : 0
	]
	angleOverride(string) : "Override Animation" : "" : "Filled in by the engine via wc_update_entity, do not edit by hand except to clear."
]

@PointClass base(prop_dynamic_base) = prop_dynamic_ornament :
	"A way to attach one studio model to another as an ornament. It will render in the way that player/NPC weapons render."
[
	solid(choices) : "Collisions" : 0 =
	[
		0: "Not Solid"
	]	

	InitialOwner(string) : "Target Entity" : : "Name of the entity that this ornament should attach to, at startup."
]








//////////////////////////////////////////////////////
//
// game entities
//
//////////////////////////////////////////////////////

@PointClass base(Targetname) = game_weapon_manager : 
	"An entity used to limit the number of a particular weapon type in the world. Useful in places where NPCs are spawning rapidly, dying, and dropping weapons." 
[
	weaponname(string) : "Weapon Classname" : "" : "Classname of the weapon type to limit."
	maxpieces(integer) : "Max Allowed in Level" : 0 : "The maximum amount of the specified weapon type allowed in the world."
	ammomod(float) : "Ammo modifier" : "1" : "Modifier for ammount of ammo dropped by a weapon."
]

@PointClass base(Targetname) = game_end : 
	"An entity that ends a multiplayer game." 
[
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_player_equip : 
	"An entity that gives equipment to the player who activates it. To use, add new keys to this entity, where each key is the classname of a weapon/item, and the corresponding value is the number of those weapons/items to give to the player who uses this entity. If the 'Use Only' spawnflag isn't set, then players can just touch this entity to get the equipment."
[
	spawnflags(flags) =
	[
		1: "Use Only" : 0
	]
	master(string) : "Team Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."	
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_player_team : 
	"An entity that changes the team of the player who activates it."
[
	spawnflags(flags) =
	[
		1 : "Remove On fire" : 0
		2 : "Kill Player" : 0
		4 : "Gib Player" : 0
	]
	target(string) : "game_team_master to use" 
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."	
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_score : 
	"An entity that awards/deducts points from the player who activates it." 
[
	spawnflags(flags) =
	[
		1: "Allow Negative" : 0
		2: "Team Points" : 0
	]

	points(integer) : "Points to add (+/-)" : 1
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
]

@PointClass base(Targetname) = game_text : 
	"An entity that displays text on player's screens." 
[
	spawnflags(flags) =
	[
		1: "All Players" : 0
	]

	message(string) : "Message Text" : "" : "Message to display onscreen."
	x(string) : "X (0 - 1.0 = left to right) (-1 centers)" : "-1" : "Horizontal position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the far left of the screen and 1 is the far right. -1 centers the text."
	y(string) : "Y (0 - 1.0 = top to bottom) (-1 centers)" : "-1" : "Vertical position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the top of the screen and 1 is the bottom. -1 centers the text."
	effect(Choices) : "Text Effect" : 0 =
	[
		0 : "Fade In/Out"
		1 : "Credits"
		2 : "Scan Out"
	]
	color(color255) : "Color1" : "100 100 100"
	color2(color255) : "Color2" : "240 110 0"
	fadein(string) : "Fade in Time (or character scan time)" : "1.5" : "The time it should take for the text to fully fade in."
	fadeout(string) : "Fade Out Time" : "0.5" : "The time it should take for the text to fade out, after the hold time has expired."
	holdtime(string) : "Hold Time" : "1.2" : "The time the text should stay onscreen, after fading in, before it begins to fade out."
	fxtime(string) : "Scan time (scan effect only)" : "0.25" : "If the 'Text Effect' is set to Scan Out, this is the time it should take to scan out all the letters in the text."
	channel(choices) : "Text Channel" : 1 : "You can have up to four individual game_text messages onscreen at once, stored in channels. Select which channel this text should be placed in, which will overwrite any active message already in that channel." =
	[
		1 : "Channel 1"
		2 : "Channel 2"
		3 : "Channel 3" 
		4 : "Channel 4"
	]
	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
]

@PointClass base(Parentname, Angles) size(-2 -2 -2, 2 2 2) = point_enable_motion_fixup : 
	"An entity used to move a motion-disabled prop when it enables motion. Parent this entity to the prop, and when the prop has its motion enabled, it will immediately teleport to the origin of this entity." []

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) = point_message : 
	"An entity that displays a text message in the world, at its origin."
[
	spawnflags(flags) =
	[
		1: "Start Disabled" : 0
	]

	message(string) : "Entity Message"
	radius(integer) : "Show message radius" : 128 : "Distance the player must be within to see this message."
	developeronly(choices) : "Developer Only?" : 0 : "If set, this message will only be visible when developer mode is on." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@PointClass base(Targetname, Parentname, RenderFields, Angles, DXLevelChoice) = point_spotlight : 
	"An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. "+
	"Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests."
[
	spawnflags(Flags) = 
	[
		1 :  "Start On" : 1
		2 :  "No Dynamic Light" : 1
	]

	IgnoreSolid(choices) : "Ignore Solid" : 0 : "If set, this spotlight won't trace for solids." =
	[
		0 : "No"
		1 : "Yes"
	]

	spotlightlength(integer) : "Spotlight Length" : 500 : "Length of the spotlight beam."
	spotlightwidth(integer) : "Spotlight Width" : 50 : "Width of the spotlight beam."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."

]

@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) = point_tesla : 
	"An entity that creates tesla lightning arcs around its origin."
[
	m_SourceEntityName(string) : "Source Entity" : "" : "If specified, tesla lightning will originate from the specified entity. Otherwise, they originate from this entity."
	m_SoundName(string) : "Sound Name" : "DoSpark" : "Sound to be played whenever lightning is created."

	texture(sprite) : "Sprite Name" : "sprites/physbeam.vmt" : "Material to use for the tesla lightning beams."

	m_Color(color255) : "Color" : "255 255 255"

	m_flRadius(integer) : "Radius" : 200 : "Radius around the origin to find a point to strike with a tesla lightning beam."

	beamcount_min(integer) : "Min # of Beams" : 6 : "Minimum number of tesla lightning beams to create when creating an arc."
	beamcount_max(integer) : "Max # of Beams" : 8 : "Maximum number of tesla lightning beams to create when creating an arc."
	
	thick_min(string) : "Min Beam Width" : "4" : "Minimum width of the tesla lightning beams."
	thick_max(string) : "Max Beam Width" : "5" : "Maximum width of the tesla lightning beams."
	
	lifetime_min(string) : "Min Time Visible" : "0.3" : "Minimum lifetime of the tesla lightning beams."
	lifetime_max(string) : "Max Time Visible" : "0.3" : "Maximum lifetime of the tesla lightning beams."
	
	interval_min(string) : "Min Time Between Arcs":"0.5" : "Minimum time delay between random arcing."
	interval_max(string) : "Max Time Between Arcs":"2" : "Maximum time delay between random arcing."
]

@PointClass base(Targetname) = point_clientcommand : 
	"An entity that issues commands to the client console, as if it was typed in by the player (if activator is a player, or the local player in single player)." []

@PointClass base(Targetname) = point_servercommand : 
	"An entity that issues commands to the server console." []

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_bonusmaps_accessor : 
	"An entity that relays bonus maps changes."
[
	filename(string) : "File Name" : ""
	mapname(string) : "Map Name" : ""
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_ui : 
	"An entity used to override player input when the player is looking at it."
[
	spawnflags(flags) =
	[
		32 : "Freeze Player" : 1
		64 : "Hide Weapon" : 1
		128 : "+Use Deactivates" : 1
		256 : "Jump Deactivates" : 1
	]
	
	FieldOfView(float) : "FieldOfView" : "-1.0" : "The amount of tolerance in the view checking when determining whether the player's input is still under control. 1.0 = straight ahead, 0.0 = +/- 90 degrees, -1.0 = all directions. If the player isn't within the tolerance, the player regains control."
]

@SolidClass base(Targetname, Parentname) = game_zone_player : 
	"An entity used to count the number of players within a zone." []





//////////////////////////////////////////////////////
//
// triggers
//
//////////////////////////////////////////////////////

@SolidClass base(Targetname) = trigger_autosave : "A trigger volume that autosaves when the player touches it."
[
	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	NewLevelUnit(choices) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels." =
	[
		0 : "No"
		1 : "Yes"
	]
	DangerousTimer(float) : "Dangerous Timer" : "0" : "The number of seconds the player must survive before this autosave takes effect."
	MinimumHitPoints(integer): "Minumum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
]

@SolidClass base(EnableDisable) = trigger_changelevel : 
	"An entity that triggers a level change. " +
	"Place an info_landmark in both maps that marks the 'same' location in each map. "+
	"TIPS & TRICKS: To fire events in the next level, use the OnLevelChange output to turn on "+
	"an env_global in the current level.  Create a logic_auto in the next level that checks "+
	"for the state set by the env_global. "+
	"To control which entities go through the level transition, create one or more trigger_transitions and "+
	"give them the same name as the landmark. Any entities within the trigger_transition(s) will go to the next map."
[
	targetname(string) : "Name"
	map(string) : "New Map Name"
	landmark(string) : "Landmark Name"
	spawnflags(flags) =
	[
		2: "Disable Touch" : 0
		4: "To Previous Chapter" : 0
	]
]

@SolidClass base(Trigger) = trigger_gravity : 
	"A trigger volume that changes the gravity on any entity that touches it."
[
	gravity(integer) : "Gravity (0-1)" : 1
]

@SolidClass base(Trigger, Targetname) = trigger_hurt :
	"A trigger volume that damages entities that touch it."
[
	damage(integer) : "Damage" : 10 : "The amount of damage done to entities that touch this trigger. The damage is done every half-second. See also 'Damage Model' for extra details on how damage can be dealt."
	damagecap(integer) : "Damage Cap" : 20 : "Maximum damage dealt per second. This field is only used if you select the Doubling w/Forgiveness damage model, via the spawnflag."
	damagetype(choices) : "Damage Type" : 0 =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]

	damagemodel(choices) : "Damage Model" : 0 : "How damage is dealt. Normal always does the specified amount of damage each half second. Doubling starts with the specified amount and doubles it each time it hurts the toucher. Forgiveness means that if the toucher gets out of the trigger the damage will reset to the specified value. Good for making triggers that are deadly over time without having to cause massive damage on each touch." =
	[
		0 : "Normal"
		1 : "Doubling w/forgiveness"
	]
	
	nodmgforce(choices) : "Zero Damage Force" : 0 : "Should the damaged entity receive no physics force from this trigger." =
	[
		0 : "No"
		1 : "Yes"
	]
]

@SolidClass base(Targetname, Angles) = trigger_impact : 
	"A trigger volume that can be told to push all physics objects that are inside of it in the direction specified by this trigger's angles.\n"+
	"Also outputs the force at the time of impact for anyone else that wants to use it."
[
	Magnitude(float) : "Magnitude" : "200" : "The strength of the impact. Negative values reverse the direction."
	noise(float) : "Noise" : "0.1" : "The amount of directional noise (0-1). 0 = no noise, 1 = random direction."
	viewkick(float) : "Viewkick" : "0.05" : "The amount to kick player's view if the player is in the trigger.  Proportional to magnitude (0-1)."
]

@SolidClass base(Trigger) = trigger_look :
	"An entity used to trigger something when the player looks at something. It fires 'OnTrigger' when the player "+
	"looks at a target entity for the given amount of time, while within the trigger volume. If the player leaves "+
	"the trigger or looks away from the target entity the clock resets. If the 'Use Velocity instead of facing' spawnflag " +
	"is checked, the trigger uses the player's velocity instead of the player's view, so it determines whenever the player "+
	"is moving toward the target entity. Useful for triggering when players are driving a vehicle at something."+
	"NOTE: Only designed for single-player game. "
[
	spawnflags(flags) = 
	[ 
		128: "Fire Once" : 1 
		256: "Use Velocity instead of facing" : 0
	]
	
	target(string) : "Look Target" : : "The name of the entity to be looked at."
	LookTime(string) : "LookTime" : "0.5" : "The time, in seconds, that the player must look the target before firing the output. Resets if player leaves trigger, or looks outside the Field of View threshold."
	FieldOfView(string) : "FieldOfView" : "0.9" : "How close the player has to be looking at the target. 1.0 = straight ahead\n 0.0 = +/- 90 degrees\n -1.0 = all directions)."
	Timeout(float) : "Timeout" : "0" : "The time, in seconds, to wait after player enters the trigger before firing the OnTimeout output, 0 = never."
]

@SolidClass base(Trigger) = trigger_multiple : "Many-time trigger"
[
	wait(integer) : "Delay Before Reset" : 1 : "Amount of time, in seconds, after the trigger_multiple has triggered before it can be triggered again. If set to -1, it will never trigger again (in which case you should just use a trigger_once)."
]

@SolidClass base(Trigger) = trigger_once : "One-time trigger" []

@SolidClass base(Trigger) = trigger_playermovement : 
	"An entity that can be used to disable player's automatic ducking/unducking when jumping."
[
	spawnflags(flags) = 
	[
	// Remove this after maps fixed up:
		16: "(OBSOLETE, Uncheck me)" : 0
		128: "Disable auto player movement" : 1
		2048: "Auto-duck while in trigger" : 0
	]
]

@SolidClass base(Trigger) = trigger_proximity :
	"Measures the distance of the player within the trigger volume from a given point (and within " +
	"a given radius). The NearestPlayerDistance output will be 0 when the player is at the center point, " +
	"and 1 when the player is at the radius."
[
	measuretarget(string) : "Point to Measure From" : : "The name of a target entity who's origin is the point to measure the player's distance from."
	radius(integer) : "Radius to measure within" : 256 : "The radius to which the distance should be mapped. If the player is outside the radius he will be ignored."
]

@SolidClass base(Trigger) = trigger_push : 
	"A trigger volume that pushes entities that touch it."
[
	pushdir(angle) : "Push Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touched entities."

	spawnflags(flags) = 
	[ 
		128: "Once Only" : 0
		256: "Affects Ladders (Half-Life 2)" : 0 
	]

	speed(integer) : "Speed of Push" : 40 : "The speed at which to push entities away, in inches / second."
]

@SolidClass base(Trigger, Targetname) = trigger_remove : 
	"A trigger volume that removes any entities that touch it. Be careful, removing some entities can cause instability. "+
	"This is not the same as killing entities. i.e. NPCs removed in this manner will not fire their OnKilled outputs." []
	
@SolidClass base(Targetname) = trigger_serverragdoll : 
	"A volume that forces any NPC inside it to create a server side ragdoll instead of a client one." []

@SolidClass base(Trigger) = trigger_soundscape : 
	"Soundscape trigger. " +
	"It is not necessary to create outputs for this trigger. It automatically will trigger the " +
	"soundscape referred to by its 'Soundscape' property."
[
	soundscape(string) : "Soundscape" 
]


@SolidClass base(Trigger) = trigger_teleport : "Teleporter"
[
	target(string) : "Remote Destination" : "" : "The entity specifying the point to which entities should be teleported."
	landmark(string) : "Local Destination Landmark" : "" : "If specified, then teleported entities are offset from the target by their initial offset from the landmark."
	spawnflags(flags) =
	[
		32: "Preserve angles even when a local landmark is not specified" : 0
	]
]

@SolidClass base(Trigger) = trigger_teleport_relative : 
	"A trigger volume that teleports entities that touch it. Entities are teleported by Offset from their current position. Useful to get " +
	"objects out of situations where levels or entities suddenly appear interseting with them."
[
	teleportoffset(vector) : "Offset (X Y Z)" : "0 0 0" : "The offset (in World-Space Coordinates X Y Z) to teleport the entity when the trigger is touched."
]

@SolidClass base(Targetname) = trigger_transition : 
	"A volume that's used to control which entities go through the level transition. Create one or more trigger_transitions and "+
	"give them the same name as the changelevel landmark. Any entities within the trigger_transition(s) will go to the next map. "+
	"See trigger_changelevel for more info." []

@SolidClass base(Trigger, Angles) = trigger_wind : 
	"A trigger volume that pushes physics objects that touch it."
[
	Speed(integer) : "Speed" : 200   : "The baseline for how hard the wind blows."
	SpeedNoise(integer) : "Speed Noise" : 0 : "Noise added to wind speed +/-"
	DirectionNoise(integer) : "Direction Noise" : 10 : "Noise added to wind direction."
	HoldTime(integer) : "Hold Time" : 0 : "Baseline for how long to wait before changing wind."
	HoldNoise(integer) : "Hold Noise" : 0 : "Noise added to how long to wait before changing wind."
]





//////////////////////////////////////////////////////
//
// AI
//
//////////////////////////////////////////////////////

@PointClass base(Targetname, ResponseContext, EnableDisable) = ai_speechfilter : 
	"An entity that can be used to control the idle speech patterns of a set of NPCs."
[
	subject(string) : "Subject(s)" : "" : "This is the NPC(s) whose speech we're filtering. May be a targetname or a classname."

	IdleModifier(float) : "Idle modifier." : "1.0" : "Multiplier to the percentage chance that our NPC(s) will idle speak. Set to 0 to prevent all idle speech."
	NeverSayHello(choices) : "Greet Player?" : 0 : "If set to Yes, our NPC(s) won't greet the player when they first meet him." =
	[
		0 : "Yes"
		1 : "No"
	]
]